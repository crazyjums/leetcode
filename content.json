{"meta":{"title":"Crazyjums Leetcode","subtitle":"Pary For A Good Life","description":"","author":"Crazy Jums","url":"http://jums.club","root":"/leetcode/"},"pages":[{"title":"All Categories","date":"2020-11-10T07:32:31.000Z","updated":"2020-11-10T08:05:06.427Z","comments":true,"path":"categories/index.html","permalink":"http://jums.club/categories/index.html","excerpt":"","text":""},{"title":"关于作者","date":"2020-11-10T01:42:21.000Z","updated":"2020-11-13T08:26:25.258Z","comments":true,"path":"about/index.html","permalink":"http://jums.club/about/index.html","excerpt":"","text":"我的个人简历https://jums.club/leetcode/images/resume.pdf 1 基本信息 姓名：朱洪根 性别：男 暂住：北京 年龄：24 | 属鼠 电话：15959963313（微信同） GitHub：https://github.com/crazyjums 个人博客：https://jums.club/ 学历：研究生 | 计算机专业 PDF版简历：我的简历-PDF 2 教育经历2.1 本科阶段 时间：2014.09-2018.07 学校：华北科技学院 专业：网络工程 主修课程：网络工程、计算机网络、操作系统、java程序设计、C语言程序设计、数据库设计等 通过了英语四级 大一、大二期间参加了爱心社、体育部等社团 参与过： 参加过华为、思科网路大赛，都进了地区赛 参加过学校组织的培训（网络方向、Java编程语言） 2.2 研究生阶段 时间：2018.09-2021.07 学校：华北科技学院 专业：计算机专业（研究方向是：数据预测） 荣誉奖项： 多次获得一等或二等奖学金 研究生期间，当过大四本科生的辅导员 第三届研究生网络与信息安全技术大赛暨京津冀高校研究生网络与信息安全技术大赛三等奖 3 项目经验 基于Spring Boot+Mysql+Bootstrap的微服务系统（公司实习项目） 设计与java开发 2019年06月 - 2019年09月 北京 根据公司的业务需求，经过需求分析-&gt;详细设计-&gt;软件开发-&gt;测试与调试四个阶段，开发出整套微服务系统 使用Mybatis框架简化程序与数据库的操作，提升了开发效率 本项目的难点之一在于如何将MaxCompute的计算结果当做参数传递给Java中的方法，我的解决方案是用Mysql数 据库作为中间缓存，让Java程序直接读取Mysql数据库中的内容便间接实现了参数传递 基于公有云平台的数据分析以及可视化研究（横向项目） 根据公司业务和需求画出算法模型，并通过阿里云的MaxCompute实现对应算法功能并通过DataV进行数据可视化 相对于服务集群而言，该方法效率更高、价格更便宜 三江源监测数据有效性分析系统（课题组项目） 该系统能将获取的数据进行及时在线甄别和审核，实现在线预警，并保存每次审核记录，能够进行追溯和定位 能够对数据的趋势进行分析、各个站点出现异常数据的几率进行分析 该系统申请了一个软件著作权，本人排名第三 安全事故信息系统（课题组项目）| 软著这是研究生课题组的一个项目，我对该系统中的部分模块进行了开发，参与了系统的前期设计 利用Bootstrap和Jquery开发前台界面，并将数据存到SQL server中 利用Echart组件将数据通过图表的形式显示到界面 java框架用的是Struts，用于编写数据计算的算法和逻辑 4 专业技能 编程语言：Java、Python、C++ 掌握基本的数据结构与算法、常用的设计模式、TCP/IP协议 了解java多态、JVM、多线程、反射等 掌握Linux、git的基本用法 5 荣誉奖项 大一、大二获得学校一等奖学金，2015-2016年 大三获得励志奖学金，2017年 硕士期间多次获得一等和二等奖学金，2018-2020年 研一暑假参加《第三届研究生网络与信息安全技术大赛暨京津冀高校研究生网络与信息安全技术大赛》并获得三等 奖，2019年 英语四级，437分 6 个人爱好 游泳健身（每周四次） 喜欢的音乐： 李志、许巍、李建、Pink Floyd 看书（坚持每周看一本书）| 看书主页 看电影（喜欢看各种豆瓣高分电影）| 电影主页 写博客（将一些自己在编程或学习中遇到的错误以及解决错误的方法和方法写成博客，与大家分享）| CSDN | 简书 | 知乎 | DIY BLOG | 豆瓣主页 7 自我评价 学习能力强、抗压能力强、动手能力强； 年轻有活力，积极向上。 8 其他8.1 微信公众号 8.2 作者"},{"title":"My Friends","date":"2020-11-10T08:03:59.000Z","updated":"2020-11-10T08:48:25.092Z","comments":true,"path":"friends/index.html","permalink":"http://jums.club/friends/index.html","excerpt":"来者都是客。","text":"来者都是客。"},{"title":"All Tags","date":"2020-11-10T07:32:13.000Z","updated":"2020-11-10T08:05:14.575Z","comments":true,"path":"tags/index.html","permalink":"http://jums.club/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"剑指 Offer 54. 二叉搜索树的第 k 大节点","slug":"kthlargest","date":"2020-11-24T08:28:16.000Z","updated":"2020-11-24T08:30:20.509Z","comments":true,"path":"kthlargest/","link":"","permalink":"http://jums.club/kthlargest/","excerpt":"剑指 Offer 54. 二叉搜索树的第k大节点https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/","text":"剑指 Offer 54. 二叉搜索树的第k大节点https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/ 1 题目 给定一棵二叉搜索树，请找出其中第k大的节点。示例 1: 输入: root = [3,1,4,null,2], k = 1&nbsp; &nbsp; 3&nbsp; / &nbsp; \\1 &nbsp; &nbsp; 4&nbsp; \\ &nbsp; &nbsp; 2输出: 4示例2: 输入: root = [5,3,6,2,4,null,null,1], k = 3&nbsp; &nbsp; 5&nbsp; / &nbsp; \\ &nbsp; 3 &nbsp; 6 &nbsp; / \\2 &nbsp; 4 / 1 输出: 4 限制： 1 ≤ k ≤ 二叉搜索树元素个数 作者：画手大鹏链接：https://leetcode-cn.com/leetbook/read/illustrate-lcof/xspy85/来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 2 中序遍历该方法为先使用一个集合类容器放置该树的中序遍历的结果序列，因为二叉搜索树的中序遍历是一个升序的序列，那么第$k$大的数则为第$list.size()-k$个数。 123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int kthLargest(TreeNode root, int k) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); inOrder(root, res); return res.get(res.size() - k); &#125; private void inOrder(TreeNode root, List&lt;Integer&gt; res) &#123; if (root == null) return; inOrder(root.left, res); res.add(root.val); inOrder(root.right, res); &#125;&#125; 这种算法的时间复杂度和空间复杂度都是$O(n)$，其中$n$是二叉搜索树的节点个数，那么这种方法并没有利用二叉搜索树的性质。 3 改进版我们知道二叉搜索树的左子树的所有值都小于根节点的值，右子树的所有值都大于根节点的值。且中序遍历的序列是一个升序的序列，那么中序遍历的顺序是left-&gt;root-&gt;right。这种遍历方式决定了中序遍历的结果是一个升序的序列，题目中要求返回第$k$大的数，那么就是中序遍历序列从后往后算起第$k$个数。我们可以不用遍历完这棵树，只需要遍历$k$次即可，我们修改树的遍历次序，改为right-&gt;root-left。那么遍历的最终的结果就是一个降序的序列。我们定义一个全局的索引，判断当前遍历到了第几个节点，当遍历到第$k$个节点时，我们就可以结束遍历返回结果。 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private int index = 0, res = 0; public int kthLargest(TreeNode root, int k) &#123; this.index = k; dfs(root); return res; &#125; private void dfs(TreeNode root) &#123; if (root == null) return; dfs(root.right); index--; if (index == 0) &#123; res = root.val; return; &#125; dfs(root.left); &#125;&#125;","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"树","slug":"LeetCode刷题/树","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E6%A0%91/"},{"name":"simple","slug":"LeetCode刷题/树/simple","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E6%A0%91/simple/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://jums.club/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"simple","slug":"simple","permalink":"http://jums.club/tags/simple/"},{"name":"树","slug":"树","permalink":"http://jums.club/tags/%E6%A0%91/"}]},{"title":"剑指 Offer 28. 对称的二叉树","slug":"mirror-tree","date":"2020-11-24T07:59:00.000Z","updated":"2020-11-24T08:02:02.547Z","comments":true,"path":"mirror-tree/","link":"","permalink":"http://jums.club/mirror-tree/","excerpt":"剑指 Offer 28. 对称的二叉树https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/","text":"剑指 Offer 28. 对称的二叉树https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/ 1 题目 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \\ 2 2 / \\ / \\3 4 4 3但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \\ 2 2 \\ \\ 3 3示例 1：输入：root = [1,2,2,3,4,4,3]输出：true示例 2：输入：root = [1,2,2,null,3,null,3]输出：false限制：0 &lt;= 节点个数 &lt;= 1000注意：本题与主站 101 题相同：https://leetcode-cn.com/problems/symmetric-tree/作者：画手大鹏链接：https://leetcode-cn.com/leetbook/read/illustrate-lcof/xsrxq1/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 2 深度优先搜索有以下几种情况： 左子树为空，右子树也为空 $true$ 左子树为空，右子树不为空 $false$ 左子树不为空，右子树为空，$false$ 左子树不为空，右子树也不为空，进行进一步的判断 左子树的值等于右子树的值，继续判断。如果所有的左右子树都满足这一条，则是$true$ 左右子树的值不相等，$false$ 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if (root == null) return true; return dfs(root, root); &#125; private boolean dfs(TreeNode left, TreeNode right) &#123; if (left == null &amp;&amp; right == null) return true; if (left == null || right == null) return false; //这里不能用else，如果用了else，那么后面的return语句就不能被执行 return (left.val == right.val) &amp;&amp; dfs(left.left, right.right) &amp;&amp; dfs(left.right, right.left); &#125;&#125; 3 广度优先搜索判断思路与上面的深度优先搜索的思路相同，只不过这里使用广度优先搜索的方法进行求解。 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if (root == null || (root.left == null &amp;&amp;root.right == null)) return true; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.add(root.left); q.add(root.right); while (!q.isEmpty()) &#123; TreeNode l = q.poll(); TreeNode r = q.poll(); if (l == null &amp;&amp; r == null) continue; //这里不能直接返回true，应该继续判断，知道整棵二叉树都满足该特点 if (l == null || r == null) return false; if (l.val != r.val) return false; q.add(l.left); q.add(r.right); q.add(l.right); q.add(r.left); &#125; return true; &#125;&#125;","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"树","slug":"LeetCode刷题/树","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E6%A0%91/"},{"name":"simple","slug":"LeetCode刷题/树/simple","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E6%A0%91/simple/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://jums.club/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"simple","slug":"simple","permalink":"http://jums.club/tags/simple/"},{"name":"树","slug":"树","permalink":"http://jums.club/tags/%E6%A0%91/"}]},{"title":"剑指 Offer 19. 正则表达式匹配","slug":"is-match-1","date":"2020-11-23T11:28:40.000Z","updated":"2020-11-23T11:30:56.620Z","comments":true,"path":"is-match-1/","link":"","permalink":"http://jums.club/is-match-1/","excerpt":"剑指 Offer 19. 正则表达式匹配https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/","text":"剑指 Offer 19. 正则表达式匹配https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/ 1 题目 请实现一个函数用来匹配包含’. ‘和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但与”aa.a”和”ab*a”均不匹配。 示例 1: 输入:s = “aa”p = “a”输出: false解释: “a” 无法匹配 “aa” 整个字符串。示例 2: 输入:s = “aa”p = “a*”输出: true解释: 因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。示例 3: 输入:s = “ab”p = “.“输出: true解释: “.“ 表示可匹配零个或多个（’*’）任意字符（’.’）。示例 4: 输入:s = “aab”p = “cab”输出: true解释: 因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。示例 5: 输入:s = “mississippi”p = “misisp*.”输出: falses 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 ，无连续的 ‘‘。注意：本题与主站 10 题相同：https://leetcode-cn.com/problems/regular-expression-matching/ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2 分析使用正则表达式进行求解。将两个字符串从后往前进行比较，其中模式串的最后一个字符可能由一下三种情况： 正常字符（[a-zA-Z]） 星号（*） 点号（.） 定义主串为$s$，长度为$m$，模式串为$p$，长度为$n$。则有一下三种情况： $p[n - 1]$为一个正常字符，则此时只能将模式串的最后一个字符和主串的最后一个字符进行比较，如果模式串的最后一个字符等于主串的最后一个字符（$p[n - 1] == s[m-1]$），则继续判断$p[n-2]$是否等于$s[m-2]$，以此类推。 $p[n-1]==’.’$。因为题目中说，$’.’$可以匹配任何一个字符，所以模式串和主串的最后一个就相当于匹配上了，继续匹配$p[n-2]$和$s[m-2]$。 $p[n-1]==’‘$。题目中说$’‘$可以匹配$’*’$号之前的那个字符任意多次（包括0次），假设$p[n-2]==c$，则主串中的字符可以匹配$c$0次或者多次： 匹配0次。那么模式串的最后两个字符就可以不用看了，因为主串被匹配了0次。比如：$s=”abc”$，$p=”abcd*”$，可将$p$的倒数第二个字符$d$认为匹配了0次，所以主串和模式串可以匹配。 匹配了多次。此种情况必须满足$s[m-1]==c$或者$c=’.’$，否则将不能匹配多次。比如：$s=”abc”$，$p=”abc*”$，可以认为字符$’c’$匹配了1次；或者$s=”abc”$，$p=”ab.*”$，此时两个串也可以匹配上。 上面将所有的可能情况都列举了，那么此时只需要定义一个$dp$数组即可，其中$dp[i][j]$表示$s$串的前$i$个字符和$p$串的前$j$个字符能否匹配。此时又分成以下4中情况： 主串为空，模式串也为空，那么此时一定可以匹配 主串为空，模式串不为空，此时不能直接得出结果，必须通过计算得出，比如$s=””$，$p=”abc*”$，此种情况两个串可以匹配。 主串不为空，模式串为空，此时一定不能匹配。 主串不为空，模式串也不为空，那么此时就需要计算得出结果 3 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class Solution &#123; public boolean isMatch(String s, String p) &#123; int m = s.length(); int n = p.length(); boolean[][] dp = new boolean[m + 1][n + 1]; /* 定义dp数组，dp[i][j]表示s串的前i个字符和p串的前j个字符是否匹配 有一下四种情况： 1. 主串为空， 模式串也为空， 此种情况可以匹配 2. 主串为空， 模式串为非空， 此种情况不能直接判断是否能匹配，需要计算 3. 主串非空， 模式为空， 此时一定不能匹配 4. 主串和模式串都是非空， 此时需要计算 计算规则如下：从后往前匹配，可以将一个大的问题转化为一个子问题 模式串的最后一个字符有三种可能：正常字符，星号（*），点（.） 1. 如果p的最后一个字符是正常字符，则判断： - p[n - 1] == s[m - 1]，则继续匹配s和p的倒数第二个字符 dp[i][j] = dp[i - 1][j - 1] - p[n - 1] != s[m - 1]，则说明最后一个字符不匹配 dp[i][j] = false 2. 如果p的最后一个字符是&quot;.&quot;，说明可以匹配任何字符，此时继续匹配倒数第二个字符 dp[i][j] = dp[i - 1][j - 1] 3. 如果p的最后一个字符是“*”，表示“*”之前的一个字符（p[n - 1] = c）可以出现0次或多次， - 出现0次：即表示p串的最后两个字符可以不用比较，直接比较s[n - 1]和p[n - 3]，dp[i][j] = dp[i][j - 2] - 出现多次：此种情况下，要求s[m - 1] == p[n- 1] || p[n - 1] == &#x27;.&#x27;，模式串不动，主串继续向前移动。 dp[i][j] = [i - 1][j] */ dp[0][0] = true; // for (int i = 1; i &lt; n; i++) &#123; // dp[0][i] = false; // &#125; for (int i = 0; i &lt;= m; i++) //主串 for (int j = 0; j &lt;= n; j++) &#123; //模式匹配串 //如果模式串是空串 //1.主串为空， 模式串也为空， 此种情况可以匹配 //2.主串非空， 模式为空， 此时一定不能匹配 if (j == 0) &#123; dp[i][j] = i == 0; &#125; else &#123; // char ch = p.charAt(j - 1); if (p.charAt(j - 1) != &#x27;*&#x27;) &#123; //将正常字符和“.”合并处理 if (i &gt; 0 &amp;&amp; (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == &#x27;.&#x27;)) &#123; dp[i][j] = dp[i - 1][j - 1]; &#125; &#125; else &#123; //出现0次 if (j &gt;= 2) &#123; dp[i][j] = dp[i][j - 2]; &#125; //出现多次 /* 关于为什么用|=，比如这段代码： //碰到 * 了， 分为看和不看两种情况 //不看 if (j &gt;= 2) &#123; f[i][j] |= f[i][j - 2]; //可用可不用，因为dp矩阵初始化默认为false，本质上和=一样 &#125; //看 if (i &gt;= 1 &amp;&amp; j &gt;= 2 &amp;&amp; (A.charAt(i - 1) == B.charAt(j - 2) || B.charAt(j - 2) == &#x27;.&#x27;)) &#123; f[i][j] |= f[i - 1][j]; //必须使用，否则不能ac &#125; 其中，第一步先算的是不看‘*’的情况，然后第二步再算看‘*’的情况。 也就是说，对于f[i][j]我们会算两次。如果在第一次，即不看&#x27;*&#x27;的时候， 就已经算出来TURE了。那在第二步看&#x27;*&#x27;的时候。不管结果是ture还是false， 都保持true不变，这是合理的，因为只要其中有一种情况能完整匹配，结果就为true。 这就是为什么要用或符号。 这个不难证明，举个例子 &quot;ba&quot; &quot;baa*&quot; 这种情况下直接用=号过不了。 */ if (i &gt;=1 &amp;&amp; j &gt;= 2 &amp;&amp; (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == &#x27;.&#x27;)) &#123; dp[i][j] |= dp[i - 1][j]; &#125; &#125; &#125; &#125; return dp[m][n]; &#125;&#125;","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"动态规划","slug":"LeetCode刷题/动态规划","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"hard","slug":"LeetCode刷题/动态规划/hard","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/hard/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://jums.club/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"hard","slug":"hard","permalink":"http://jums.club/tags/hard/"},{"name":"动态规划","slug":"动态规划","permalink":"http://jums.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"6道回溯算法题，了解以及掌握回溯法的基本套路","slug":"back-tracks","date":"2020-11-15T06:56:13.000Z","updated":"2020-11-15T12:21:41.173Z","comments":true,"path":"back-tracks/","link":"","permalink":"http://jums.club/back-tracks/","excerpt":"46. 全排列https://leetcode-cn.com/problems/permutations/","text":"46. 全排列https://leetcode-cn.com/problems/permutations/ 46. 全排列https://leetcode-cn.com/problems/permutations/ 47. 全排列 IIhttps://leetcode-cn.com/problems/permutations-ii/https://jums.club/leetcode/images/safari.png 78. 子集https://leetcode-cn.com/problems/subsets/ 90. 子集 IIhttps://leetcode-cn.com/problems/subsets-ii/) 39. 组合总和https://leetcode-cn.com/problems/combination-sum/ 40. 组合总和 IIhttps://leetcode-cn.com/problems/combination-sum-ii/ 1 使用回溯算法求46. 全排列 给定一个 没有重复 数字的序列，返回其所有可能的全排列。 示例: 输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 这是一道金典的回溯算法题，使用回溯法进行求解，我们通过在这道题来了解什么是回溯，以及掌握回溯算法的套路。回溯即重新回过头去看的意思，也就是说使用该方法进行求解时，需要不时的回头看看，我们可以画出该题的回溯树，从下面的回溯树可以看出，回溯法的求解过程类似于深度优先搜索。这里需要注意几个地方，即数组中的元素用过一次之后，不能再之后的选择中再次出现。比如第一个分支，选择了$1$之后，后面的两个分支就只能选择$2$或者$3$。其他两个分支也是类似，那么就需要一个有这么一个数据结构能够记录当前所做出的选择，并在回溯之后撤销当前所做的选择。这里我们可以使用一个相同大小的数组即可，每次做出选择时，在相同的下标位置做上标记，当回溯到上一层时，消除标记，为了判断时方便，这里使用$boolean$型数组。 1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (nums == null || nums.length == 0) &#123; return res; &#125; List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); boolean[] used = new boolean[nums.length]; //也可以使用int或者其他类型的数组，只要能标记就行 dfs(used, res, path, nums); return res; &#125; private void dfs(boolean[] used, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, int[] nums) &#123; if (path.size() == nums.length) &#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (!used[i]) &#123; path.add(nums[i]); used[i] = true; dfs(used, res, path, nums); used[i] = false; path.remove(path.size() - 1); &#125; &#125; &#125;&#125; 2 回溯算法的解题模板通过上面的题，我们应该能大概知道回溯算法的一个解题思路，通常遇到一道回溯算法题时，首先应该在抄稿纸上画出该题的回溯树，如果需要剪枝的话，还需要进行剪枝操作，这里我们可以通过47. 全排列 II这一题了解回溯法的剪枝过程。回溯算法的大致模板如下： 1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); //1、定义结果集的容器 if (nums == null || nums.length == 0) &#123; //2、判断条件下的结果 return res; &#125; List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); //3、定义单个的回溯路径容器 boolean[] used = new boolean[nums.length]; //4、定义标记数据结构，用于防止重复访问，这是非必要 dfs(used, res, path, nums); //5、进入回溯算法的递归树中 return res; //返回最终结果 &#125; private void dfs(boolean[] used, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, int[] nums) &#123; if (path.size() == nums.length) &#123; // 1、定义递归的退出条件，必须有 当回溯路径中取到所有选择时，则添加到结果集并退出递归 res.add(new ArrayList&lt;&gt;(path)); return; // 必须要返回 &#125; for (int i = 0; i &lt; nums.length; i++) &#123; // 2、当前逻辑 即做出选择，一共有多少种选择 if (!used[i]) &#123; //该步是判断当前的元素是否已经被选择过，如果没有，则需要进一步做选择，否则跳过 path.add(nums[i]); //3、将当前的选择添加到回溯分支中 used[i] = true; //并标记当前选择已经被选择过，在当前的回溯分支中该元素不能再被重新选择 dfs(used, res, path, nums); // 4、当前选择已经做好了，继续向下左选择，进入下一个回溯分支 used[i] = false; //5、如果下一个分支到头了，即到了回溯树的叶子节点处，此时即找到了一个结果，将其添加到结果集中，并向上回溯一层，即撤销当前的选择，慢慢想回溯树的根部移动，回溯到上一层后，需要撤销当前所做的选择 path.remove(path.size() - 1); //回溯一层后，需要将当前的回溯分支的叶子部分进行删除 &#125; &#125; &#125;&#125; 上面是在46. 全排列的代码基础上进行的一个分析，下面给出一个抽象的模板： 1234567891011121314151617181920212223class Solution &#123; public 结果集容器 方法名(选择列表) &#123; 1、定义结果集容器; 2、判断特殊情况下的结果; 3、定义一个存放回溯分支的容器; 4、进入回溯函数，这里定义为backTrack(); return res; &#125; private void backTrack(res, path, nums) &#123; 1、递归退出条件; 2、定义当前逻辑; for (num : nums) &#123; //列出所有的可能选择 //如果需要，可以判断当前选择是否在之前已经被选择过; path.add(num); //将当前的选择添加到回溯的分支中，当前选择必须是可以被选择的一个选择 //继续进入下一层的回溯分支 backTrack(res, path, nums); //撤销上一层所做的选择， path.remove(path.size() - 1); &#125; &#125;&#125; 3 回溯算法的剪枝-47. 全排列 II 给定一个 没有重复 数字的序列，返回其所有可能的全排列。 示例: 输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 该题是在全排列的基础上进行了改进，这里的选择中可能会出现重复的元素，但是结果集中不能有重复的解，那么使用上一题的解法定义一个标记数组来解这道题的话，也可以解出来，然后在添加到结果集中时判断一下当前的回溯分支是否已经在结果集中，如果不在，则添加，否则不添加，但是这样会出很多的无畏的操作，导致算法的时间复杂度很高。 在添加到结果集中之前，需要判断当前的回溯分支是否在结果集中，这一步的时间复杂度是$O(n)$ 由于回溯树做了很多无畏的计算，那么这一步的最坏的时间复杂度是$O(2^n)$ 下图来自力扣题解。 从上图可以看出，第二层的第三个分支被剪枝了，也就是这一个分支没有参与计算，这样就大大减小了回溯树的时间复杂度。那么我们没必要在添加到总的结果集中时才判断当前回溯是否重复，我们可以可以在回溯搜索的时候就判断，即上图中的剪枝操作，我们可以先对选择数组进行排序，然后在回溯的过程中： 如果是第一个待选择的选择，我们不需要判断，直接添加即可 如果是第二个待选择的选择时，先判断当前选择的前一个选择是否被选择过以及是否和当前的选择相等，如果和当前的选择相等的话，那么在往下的回溯分支就会和上一个的回溯分支重复，这就不符合题意，所以这一步跳过即可 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (nums == null || nums.length == 0) return res; List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); boolean[] used = new boolean[nums.length]; Arrays.sort(nums); dfs(res, path, used, nums); return res; &#125; private void dfs(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, boolean[] used, int[] nums) &#123; if (path.size() == nums.length) &#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; /** * 可以将此思路当成是由nums.length个空格，从nums数组中选择数字填到这些空格中， * 从左往右，在填右边这个元素时，要先判断一下左边的元素是否被用过，如果没有被用过，那 * 左边的元素是否和右边待填的元素相等，如果想等，也不能填 */ if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) &#123; //从第二个选择开始判断是否剪枝 continue; &#125; if (!used[i]) &#123; path.add(nums[i]); used[i] = true; dfs(res, path, used, nums); path.remove(path.size() - 1); used[i] = false; &#125; &#125; &#125;&#125; 4 回溯剪枝的模板回溯算法的剪枝，必须对选择数组进行排序，否则不可能实现。 12345678910111213141516171819202122232425class Solution &#123; public 结果集容器 方法名(选择列表) &#123; 1、定义结果集容器; 2、判断特殊情况下的结果; 3、定义一个存放回溯分支的容器; 4、进入回溯函数，这里定义为backTrack(); return res; &#125; private void backTrack(res, path, nums) &#123; 1、递归退出条件; 2、定义当前逻辑; for (int i = 0; i &lt; nums.length; i++) &#123; //列出所有的可能选择 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) //从第二个选择开始判断是否剪枝 continue; //剪枝 //如果需要，可以判断当前选择是否在之前已经被选择过; path.add(num); //将当前的选择添加到回溯的分支中，当前选择必须是可以被选择的一个选择 //继续进入下一层的回溯分支 backTrack(res, path, nums); //撤销上一层所做的选择， path.remove(path.size() - 1); &#125; &#125;&#125; 5 其他与该题类似的回溯算法题78. 子集https://leetcode-cn.com/problems/subsets/ 该题除了可以使用回溯算法解题之外，还可以结合二进制和迭代进行解题。这里只列出回溯法的，有兴趣的可以自己想想怎么用二进制求解。 12345678910111213141516171819202122class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; int n = nums.length; int m = 1 &lt;&lt; n; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); dfs(res, path, 0, nums); return res; &#125; //index表示当前查到所有选择中的第几个选择 private void dfs(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, int index, int[] nums) &#123; if (nums.length &lt; index) &#123; return; &#125; res.add(new ArrayList&lt;&gt;(path)); //由于是求子集，所以是每一个回溯都是全集的自己 for (int i = index; i &lt; nums.length; i++) &#123; path.add(nums[i]); dfs(res, path, i + 1, nums); path.remove(path.size() - 1); &#125; &#125;&#125; 90. 子集 IIhttps://leetcode-cn.com/problems/subsets-ii/) 123456789101112131415161718192021222324class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); Arrays.sort(nums); dfs(res, path, 0, nums); return res; &#125; private void dfs(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, int index, int[] nums) &#123; if (index &gt; nums.length) return; res.add(new ArrayList&lt;&gt;(path)); //同样 for (int i = index; i &lt; nums.length; i++) &#123; if (i &gt; index &amp;&amp; nums[i] == nums[i - 1]) continue; path.add(nums[i]); dfs(res, path, i + 1, nums); path.remove(path.size() - 1); &#125; &#125;&#125; 39. 组合总和https://leetcode-cn.com/problems/combination-sum/ 1234567891011121314151617181920212223242526class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); Arrays.sort(candidates); //排序的目的是为了剪枝 dfs(candidates, target, 0, 0, res, path); return res; &#125; private void dfs(int[] candidates, int target, int sum, int index, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path) &#123; if (sum == target) &#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for (int i = index; i &lt; candidates.length; i++) &#123; int rs = sum + candidates[i]; if (rs &lt;= target) &#123; path.add(candidates[i]); dfs(candidates, target, rs, i, res, path); path.remove(path.size() - 1); &#125; else &#123; //剪枝 大于target的部分可以剪枝 break; &#125; &#125; &#125;&#125; 40. 组合总和 IIhttps://leetcode-cn.com/problems/combination-sum-ii/ 1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); Arrays.sort(candidates); dfs(res, path, candidates, target, 0, 0); return res; &#125; private void dfs(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, int[] candidates, int target, int sum, int index) &#123; if (sum == target) &#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for (int i = index; i &lt; candidates.length; i++) &#123; if (i &gt; index &amp;&amp; candidates[i] == candidates[i - 1]) continue; int rs = sum + candidates[i]; if (rs &lt;= target) &#123; path.add(candidates[i]); dfs(res, path, candidates, target, rs, i + 1); path.remove(path.size() - 1); &#125; else &#123; break; &#125; &#125; &#125;&#125;","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"算法总结","slug":"LeetCode刷题/算法总结","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"name":"回溯法","slug":"LeetCode刷题/算法总结/回溯法","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E5%9B%9E%E6%BA%AF%E6%B3%95/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://jums.club/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"算法总结","slug":"算法总结","permalink":"http://jums.club/tags/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"name":"回溯法","slug":"回溯法","permalink":"http://jums.club/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"}]},{"title":"求只有a中函数有的元素而b中没有的元素，只有b中含有的元素而a中没有的元素","slug":"two-arrays","date":"2020-11-14T07:44:50.000Z","updated":"2020-11-14T07:57:52.588Z","comments":true,"path":"two-arrays/","link":"","permalink":"http://jums.club/two-arrays/","excerpt":"地平线https://www.horizon.ai/journey3.html","text":"地平线https://www.horizon.ai/journey3.html 题目：给定两个数组：求只有a中函数有的元素而b中没有的元素，只有b中含有的元素而a中没有的元素 1 解题思路这道题和LeetCode中的一个到题很像，349. 两个数组的交集，只是这里要求两个数组中互相没有的元素。思路：排序+双指针。 先给两个数组进行排序，然后定义两个指针，分别指向两个数组的开头位置，从开头开始遍历： 如果两个元素相等，则指针后移， 如果不相等， 如果$a[l1]&lt;b[l2]$，则判断$a[l1]$是否在$b$中，如果不在，则将$a[l1]$的值添加到结果集中，并$l1++$，如果在跳过 如果$a[l1]&gt;b[l2]$，则判断$b[l2]$是否在$a$中，如果不在，则将$b[l1]$的值添加到结果集中，并$l2++$，如果在跳过 12345678910111213141516171819202122232425262728293031323334353637383940414243public void twoArray(int[] a, int[] b) &#123;// int[] a = &#123;3,4,1,2,4,4,4,5&#125;;// int[] b = &#123;5,6,3,4,5,5,5&#125;; Arrays.sort(a); Arrays.sort(b); List&lt;Integer&gt; res1 = new ArrayList&lt;&gt;(); List&lt;Integer&gt; res2 = new ArrayList&lt;&gt;(); int l1 = 0; int l2 = 0; List&lt;Integer&gt; same = new ArrayList&lt;&gt;(); //记录a和b的相同元素 while (l1 &lt; a.length &amp;&amp; l2 &lt; b.length) &#123; if (a[l1] == b[l2]) &#123; same.add(a[l1]); l1 ++; l2 ++; &#125; else &#123; if (a[l1] &lt; b[l2]) &#123; if (res1.size() == 0 || !same.contains(a[l1])) &#123; res1.add(a[l1]); &#125; l1 ++; &#125; else &#123; if (res2.size() == 0 || !same.contains(b[l2])) &#123; res2.add(b[l2]); &#125; l2 ++; &#125; &#125; &#125; while (l1 &lt; a.length) &#123; if (!same.contains(a[l1])) res1.add(a[l1]); l1 ++; &#125; while (l2 &lt; b.length) &#123; if (!same.contains(b[l2])) res2.add(b[l2]); l2 ++; &#125;&#125;","categories":[{"name":"面试算法题","slug":"面试算法题","permalink":"http://jums.club/categories/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"大厂","slug":"面试算法题/大厂","permalink":"http://jums.club/categories/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/%E5%A4%A7%E5%8E%82/"}],"tags":[{"name":"面试算法题","slug":"面试算法题","permalink":"http://jums.club/tags/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"大厂","slug":"大厂","permalink":"http://jums.club/tags/%E5%A4%A7%E5%8E%82/"}]},{"title":"reverse list","slug":"reverse-list","date":"2020-11-13T11:32:32.000Z","updated":"2020-11-14T07:57:52.586Z","comments":true,"path":"reverse-list/","link":"","permalink":"http://jums.club/reverse-list/","excerpt":"31. 下一个排列https://leetcode-cn.com/problems/next-permutation/","text":"31. 下一个排列https://leetcode-cn.com/problems/next-permutation/","categories":[],"tags":[]},{"title":"环形链表问题","slug":"is-cycle","date":"2020-11-13T07:39:42.000Z","updated":"2020-11-13T11:34:56.569Z","comments":true,"path":"is-cycle/","link":"","permalink":"http://jums.club/is-cycle/","excerpt":"141. 环形链表https://leetcode-cn.com/problems/linked-list-cycle/","text":"141. 环形链表https://leetcode-cn.com/problems/linked-list-cycle/ 给定一个链表，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 如果链表中存在环，则返回 true 。 否则，返回 false 。 进阶： 你能用 O(1)（即，常量）内存解决此问题吗？ 示例 1： 输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。示例 2： 输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。示例 3： 输入：head = [1], pos = -1输出：false解释：链表中没有环。 提示： 链表中节点的数目范围是 $[0, 104]$$-105 &lt;= Node.val &lt;= 105$$pos$ 为$ -1$ 或者链表中的一个 有效索引 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/linked-list-cycle著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 1 解题思路想象一下这种场景：在足球场上，甲和乙在进行跑步比赛，已知甲和乙的速度恒定不变，且甲的速度是乙的两倍，假设乙的速度是$v$，则甲的速度是$2v$。他们在同一时刻起跑，那么最后总有这么一个时刻，甲能追上乙，即甲乙相遇。 此问题和上面的场景有点像，那么我们只需要制造甲和乙，并且指定他们的速度就可以。可以使用快慢指针$slow$、$fast$，如果链表中存在环，那么这两个指针最终一定可以相遇，即$slow==fast$。如果他们最后相等了，那么说明有环，否则说明没有。代码如下。 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if(head==null) return false; ListNode slow = head; ListNode fast = head; while(fast!=null &amp;&amp; fast.next!=null)&#123; slow = slow.next; fast = fast.next.next; if(slow == fast) return true; &#125; return false; &#125;&#125; 2 题目进阶 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。 说明：不允许修改给定的链表。 进阶： 你是否可以使用 O(1) 空间解决此题？ 示例 1： 输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。示例 2： 输入：head = [1,2], pos = 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。示例 3： 输入：head = [1], pos = -1输出：返回 null解释：链表中没有环。 提示： 链表中节点的数目范围在范围 $[0, 104]$内$-105 &lt;= Node.val &lt;= 105$$pos$ 的值为$ -1$ 或者链表中的一个有效索引 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/linked-list-cycle-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 此题目是在上一题的基础上的改进，即如果链表中存在环，那么求出环的入口节点并返回该入口节点。 假设端点$A$是链表的起始点，端点$B$是链表中环的入口节点，端点$C$是快慢指针相遇的节点，由于快指针$fast$的移动速度是慢指针$slow$的两倍，所以可以知道快指针所走过的路径是慢指针所走过的路径的两倍。看图可以知道，慢指针所走过的路径是：$x+y$；快指针所走过的路径是：$x+y+y+z$，即$x+z+2y$。则有$2(x+y)=x+z+2y$，化简后的$x=z$。 根据以上推理过程，可以知道$x$和$z$的长度一样的，那么当快慢指针相遇之后，可以将快慢指针中的某个指针移动到链表头部，此时让快慢指针以相同的速度向前进，他们最终一定会在$B$点相遇，那么$B$点就是环的入口节点。 12345678910111213141516171819public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; if (head == null || head.next == null) return null; ListNode s = head; ListNode f = head; while (f != null &amp;&amp; f.next != null) &#123; s = s.next; f = f.next.next; if (s == f) break; &#125; f = head; while (f != s &amp;&amp; s != null) &#123; s = s.next; f = f.next; &#125; return s; &#125;&#125;","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"链表","slug":"LeetCode刷题/链表","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/"},{"name":"middle","slug":"LeetCode刷题/链表/middle","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/middle/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://jums.club/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"middle","slug":"middle","permalink":"http://jums.club/tags/middle/"},{"name":"链表","slug":"链表","permalink":"http://jums.club/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"n人围成一圈报数","slug":"n-people","date":"2020-11-13T07:19:14.000Z","updated":"2020-11-13T08:07:25.650Z","comments":true,"path":"n-people/","link":"","permalink":"http://jums.club/n-people/","excerpt":"有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来的第几号的那位？","text":"有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来的第几号的那位？ 1 解题思路可以用一个数组，数组大小为$n$，需要执行$n-1$次遍历，每次遍历踢掉一个人，使用一个变量$p$来记录当前报的数，一个变量来保存当前还剩多少人，如果最后只剩下一个人，那么退出循环，否则继续。 123456789101112131415161718192021public static int nPeople(int n) &#123; int count = n; int p = 0; boolean[] a = new boolean[n]; while (count &gt; 1) &#123; for (int i = 0; i &lt; n; i++) &#123; if (!a[i]) p++; if (p == 3) &#123; a[i] = true; count --; p = 0; &#125; &#125; &#125; int res = 0; for (int i = 0; i &lt; n; i++) &#123; if (!a[i]) res = i + 1; &#125; return res;&#125; 2 题目进阶假如题目没有说从$1$报到$3$，而是从$1$报到$m$，则最后留下的那个人的编号是多少？ 在之前的基础上，进行改进即可，即对第$8$行代码进行，判断每次报数的最大值即可。 123456789101112131415161718192021public static int nPeople(int n, int m) &#123; int count = n; int p = 0; boolean[] a = new boolean[n]; while (count &gt; 1) &#123; for (int i = 0; i &lt; n; i++) &#123; if (!a[i]) p++; if (p == m) &#123; a[i] = true; count --; p = 0; &#125; &#125; &#125; int res = 0; for (int i = 0; i &lt; n; i++) &#123; if (!a[i]) res = i + 1; &#125; return res;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"http://jums.club/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://jums.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}]},{"title":"328. 奇偶链表","slug":"odd-even-list","date":"2020-11-13T02:47:06.000Z","updated":"2020-11-13T02:57:50.063Z","comments":true,"path":"odd-even-list/","link":"","permalink":"http://jums.club/odd-even-list/","excerpt":"328. 奇偶链表https://leetcode-cn.com/problems/odd-even-linked-list/","text":"328. 奇偶链表https://leetcode-cn.com/problems/odd-even-linked-list/ 给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。 请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。 示例 1: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL示例 2: 输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL说明: 应当保持奇数节点和偶数节点的相对顺序。链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/odd-even-linked-list著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 1 解题思路这里借助力扣官网的题解进行分析，首先由于奇数链表的头结点就是原始链表的第一个节点，所以定义一个奇数节点的头结点$oddHean=head$，而偶数链表的头结点则是奇数头结点的下一个节点，即$evenHead=head.next$。然后定义两个指针，一个指向奇数节点的指针$odd$，一个指向偶数节点的指针$even$，使用循环，他们的操作如下： 奇数节点的下一个节点就是偶数节点的下一个节点，所以有$odd.next=even.next$，然后奇数节点向后移动，$odd=odd.next$。 偶数节点的下一个节点就是奇数节点的下一个节点，所有有$even.next=odd.next$，然后偶数节点向后移动，$even=even.next$ 最后将偶数链表的头结点连接到奇数节点的尾部，返回奇数链表的头结点即可。 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode oddEvenList(ListNode head) &#123; ListNode newHead = new ListNode(-1); ListNode p = head; ListNode p2 = head; while (p != null &amp;&amp; p.next != null) &#123; newHead.next = p; p = p.next.next; &#125; p2 = p2.next; while (p2 != null &amp;&amp; p2.next != null) &#123; newHead.next = p2; p2 = p2.next.next; &#125; return newHead.next; &#125;&#125; 算法的时间复杂度为$O(n)$，空间复杂度是$O(1)$。","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"链表","slug":"LeetCode刷题/链表","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/"},{"name":"middle","slug":"LeetCode刷题/链表/middle","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/middle/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://jums.club/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"middle","slug":"middle","permalink":"http://jums.club/tags/middle/"},{"name":"链表","slug":"链表","permalink":"http://jums.club/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"10. 正则表达式匹配","slug":"is-match","date":"2020-11-12T12:34:25.000Z","updated":"2020-11-12T12:51:32.606Z","comments":true,"path":"is-match/","link":"","permalink":"http://jums.club/is-match/","excerpt":"10. 正则表达式匹配https://leetcode-cn.com/problems/regular-expression-matching/","text":"10. 正则表达式匹配https://leetcode-cn.com/problems/regular-expression-matching/ 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。 ‘.’ 匹配任意单个字符‘*’ 匹配零个或多个前面的那一个元素所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 示例 1： 输入：s = “aa” p = “a”输出：false解释：”a” 无法匹配 “aa” 整个字符串。示例 2: 输入：s = “aa” p = “a*”输出：true解释：因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。示例 3： 输入：s = “ab” p = “.“输出：true解释：”.“ 表示可匹配零个或多个（’*’）任意字符（’.’）。示例 4： 输入：s = “aab” p = “cab”输出：true解释：因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。示例 5： 输入：s = “mississippi” p = “misisp*.”输出：false 提示： $0 &lt;= s.length &lt;= 20$$0 &lt;= p.length &lt;= 30$s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。保证每次出现字符 * 时，前面都匹配到有效的字符 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/regular-expression-matching著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 1 解题思路本题可以使用动态规划来进行求解，定义$dp$数组，$dp[i][j]$表示字符串$s$的前$i$个字符和字符串$p$的前$j$的字符是否匹配。默认$dp[0][0]=true$，且$dp[m+1][n+1]$。 情况1：$s[i-1]==p[j-1]$或者$p[j-1]==’.’$，则表示能匹配，在匹配的情况下，则只要看第$i-1$和$j-1$的匹配情况即可，即$dp[i][j]=dp[i-1][j-1]$。 情况2： $p[j-1]=’*’$，此时表示字符串$p$之前的字符可以匹配0个、1个或者多个，分成以下几种情况 子情况1： $s[i-1]==p[j-2]$或者$p[j-2]==’.’$，表示前一个字符可以匹配，则表示$*$号之前的字符出现了一个，则$dp[i][j]=dp[i][j-1]$。 子情况2： $s[i-1]!=p[j-2]$时，此时$$可以匹配0个、1个或者多个$$号之前的字符，则 $dp[i][j]=dp[i-1][j]ordp[i][j-1]ordp[i][j-2]$。 其中$dp[i][j-2]$表示匹配0个字符，$dp[i][j-1]$表示匹配1个字符，$dp[i-1][j]$表示匹配多个字符。 123456789101112131415161718192021222324252627class Solution &#123; public boolean isMatch(String s, String p) &#123; if (p == null || s == null) return false; String s1 = &quot; &quot; + s; //避免比较空字符串 String p2 = &quot; &quot; + p; int m = s1.length(); int n = p2.length(); boolean[][] dp = new boolean[m + 1][n + 1]; dp[0][0] = true; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (s1.charAt(i - 1) == p2.charAt(j - 1) || p2.charAt(j - 1) == &#x27;.&#x27;) &#123; dp[i][j] = dp[i - 1][j - 1]; &#125; else if (p2.charAt(j - 1) == &#x27;*&#x27;) &#123; if (s1.charAt(i - 1) != p2.charAt(j - 2) &amp;&amp; p2.charAt(j - 2) != &#x27;.&#x27;) &#123; dp[i][j] = dp[i][j - 2]; //出现0次 &#125; else &#123; //s.charAt(i - 1) != p.charAt(j - 2) dp[i][j] = dp[i - 1][j] //匹配多个字符】 || dp[i][j - 2] //匹配0个字符 || dp[i][j - 1]; //匹配1个字符 &#125; &#125; &#125; &#125; return dp[m][n]; &#125;&#125;","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"动态规划","slug":"LeetCode刷题/动态规划","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"hard","slug":"LeetCode刷题/动态规划/hard","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/hard/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://jums.club/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"hard","slug":"hard","permalink":"http://jums.club/tags/hard/"},{"name":"动态规划","slug":"动态规划","permalink":"http://jums.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"15. 三数之和","slug":"three-sum","date":"2020-11-12T10:49:08.000Z","updated":"2020-11-12T12:38:27.152Z","comments":true,"path":"three-sum/","link":"","permalink":"http://jums.club/three-sum/","excerpt":"15. 三数之和https://leetcode-cn.com/problems/3sum/","text":"15. 三数之和https://leetcode-cn.com/problems/3sum/ 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例： 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/3sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 1 解题思路排序+双指针 定义三个指针$a,b,c$，然后固定其中一个，移动其中两个，假设固定$a$，然后令$b=a+1$，$c=size-1$，移动指针$b$和$c$。有以下三种情况： 大于0：即$nums[a]+nums[b]+nums[c]&gt;0$，此时应该指针$d$左移 小于0：即$nums[a]+nums[b]+nums[c]&lt;0$，此时应该指针$c$右移 等于0：添加到结果集 注意：题目中说结果集中不能含有重复结果，所以需要判断相邻元素的值是否相等，相等则跳过。 123456789101112131415161718192021222324252627282930class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); int size = nums.length; Arrays.sort(nums); for (int i = 0; i &lt;= size - 2; i ++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; //去重 int l = i + 1; int r = size - 1; while (l &lt; r) &#123; if (nums[i] + nums[l] + nums[r] &gt; 0) &#123; r --; &#125; else if (nums[i] + nums[l] + nums[r] &lt; 0) &#123; l ++; &#125; else &#123; List&lt;Integer&gt; tem = new ArrayList&lt;&gt;(); tem.add(nums[i]); tem.add(nums[l]); tem.add(nums[r]); ans.add(tem); while (l &lt; r &amp;&amp; nums[l] == nums[l + 1]) l ++; //去重 while (l &lt; r &amp;&amp; nums[r] == nums[r - 1]) r --; //去重 l ++; r --; &#125; &#125; &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"双指针","slug":"LeetCode刷题/双指针","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"middle","slug":"LeetCode刷题/双指针/middle","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E5%8F%8C%E6%8C%87%E9%92%88/middle/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://jums.club/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"middle","slug":"middle","permalink":"http://jums.club/tags/middle/"},{"name":"双指针","slug":"双指针","permalink":"http://jums.club/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"18.四数之和","slug":"four-sum","date":"2020-11-12T10:31:44.000Z","updated":"2020-11-12T10:59:37.552Z","comments":true,"path":"four-sum/","link":"","permalink":"http://jums.club/four-sum/","excerpt":"18. 四数之和https://leetcode-cn.com/problems/4sum/","text":"18. 四数之和https://leetcode-cn.com/problems/4sum/ 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/4sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 1 解题思思路：排序+双指针 在15. 三数之和的基础上，多定义一个下届即可，定义四个指针，$a,b,c,d$，先固定$a$和$b$，$b=a+1$，然后再定义双指针$c$和$d$，令$c=b+1$，$d=size-1$，然后判断这四个指针的数值的和是否与$target$的结果： 当$nums[a]+nums[b]+nums[c]+nums[d]==target$，符合要求，添加到结果集中 当$nums[a]+nums[b]+nums[c]+nums[d]&gt;target$，太大，应该让指针$d$左移动 当$nums[a]+nums[b]+nums[c]+nums[d]&lt;target$，太小，应该让指针$c$右移动 注意：在计算时，要防止各个指针所指向的值是否想等，如果某一个指针的前一个值和后一个相等，则不参与计算，因为结果集中不能出现重复结果。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); int size = nums.length; if (size &lt; 4) return ans; Arrays.sort(nums); for (int a = 0; a &lt;= size- 4; a ++) &#123; if (a &gt; 0 &amp;&amp; nums[a] == nums[a - 1]) continue; //去重 for (int b = a + 1; b &lt;= size - 3; b ++) &#123; if (b &gt; a + 1 &amp;&amp; nums[b] == nums[b - 1]) continue; //去重 int c = b + 1; int d = size - 1; while (c &lt; d) &#123; if (nums[a] + nums[b] + nums[c] + nums[d] &lt; target) &#123; c ++; &#125; else if (nums[a] + nums[b] + nums[c] + nums[d] &gt; target) &#123; d --; &#125; else &#123; List&lt;Integer&gt; tem = new ArrayList&lt;&gt;(); tem.add(nums[a]); tem.add(nums[b]); tem.add(nums[c]); tem.add(nums[d]); ans.add(tem); while (c &lt; d &amp;&amp; nums[c + 1] == nums[c]) c++; //去重 while (c &lt; d &amp;&amp; nums[d - 1] == nums[d]) d--; //去重 c++; d--; &#125; &#125; &#125; &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"middle","slug":"LeetCode刷题/middle","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/middle/"},{"name":"双指针","slug":"LeetCode刷题/middle/双指针","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/middle/%E5%8F%8C%E6%8C%87%E9%92%88/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://jums.club/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"middle","slug":"middle","permalink":"http://jums.club/tags/middle/"},{"name":"双指针","slug":"双指针","permalink":"http://jums.club/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"514. 自由之路","slug":"find-rotate-steps","date":"2020-11-12T07:23:42.000Z","updated":"2020-11-12T12:38:11.090Z","comments":true,"path":"find-rotate-steps/","link":"","permalink":"http://jums.club/find-rotate-steps/","excerpt":"514. 自由之路， https://leetcode-cn.com/problems/freedom-trail/https://jums.club/leetcode/images/safari.png","text":"514. 自由之路， https://leetcode-cn.com/problems/freedom-trail/https://jums.club/leetcode/images/safari.png 电子游戏“辐射4”中，任务“通向自由”要求玩家到达名为“Freedom Trail Ring”的金属表盘，并使用表盘拼写特定关键词才能开门。 给定一个字符串 ring，表示刻在外环上的编码；给定另一个字符串 key，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的最少步数。 最初，ring 的第一个字符与12:00方向对齐。您需要顺时针或逆时针旋转 ring 以使 key 的一个字符在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完 key 中的所有字符。 旋转 ring 拼出 key 字符 key[i] 的阶段中： 您可以将 ring 顺时针或逆时针旋转一个位置，计为1步。旋转的最终目的是将字符串 ring 的一个字符与 12:00 方向对齐，并且这个字符必须等于字符 key[i] 。如果字符 key[i] 已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作 1 步。按完之后，您可以开始拼写 key 的下一个字符（下一阶段）, 直至完成所有拼写。示例： 输入: ring = “godding”, key = “gd”输出: 4解释: 对于 key 的第一个字符 ‘g’，已经在正确的位置, 我们只需要1步来拼写这个字符。 对于 key 的第二个字符 ‘d’，我们需要逆时针旋转 ring “godding” 2步使它变成 “ddinggo”。 当然, 我们还需要1步进行拼写。 因此最终的输出是 4。提示： ring 和 key 的字符串长度取值范围均为 1 至 100；两个字符串中都只有小写字符，并且均可能存在重复字符；字符串 key 一定可以由字符串 ring 旋转拼出。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/freedom-trail著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 1 解题思路使用动态规划进行求解，$dp[i][j]$表示字符串$key$中的第$i$个字符和$ring$中的第$j$个字符对应时，所需要的最小转换步数。由于题目中说： 可以顺时针和逆时针转动 可以有重复字符 所以增加了题目的难度，不能使用贪心算法，得用动态规划进行求解。 状态转移方程： $dp[i][j]=max(dp[i][j],dp[i][k]+1+min(abs(j-k),abs(n-(j-k))))$ 其中$n$表示$ring$的长度，$1+min(abs(j-k),abs(n-(j-k)))$表示$key$中的第$k$个字符对应在$ring$中的索引转换到$ring$中第$j$个字符所需要的最短步数。 123456789101112131415161718192021222324252627class Solution &#123; public int findRotateSteps(String ring, String key) &#123; int n = ring.length(), m = key.length(); List&lt;Integer&gt;[] pos = new List[26]; for (int i = 0; i &lt; 26; ++i) &#123; pos[i] = new ArrayList&lt;Integer&gt;(); &#125; for (int i = 0; i &lt; n; ++i) &#123; pos[ring.charAt(i) - &#x27;a&#x27;].add(i); &#125; int[][] dp = new int[m][n]; for (int i = 0; i &lt; m; ++i) &#123; Arrays.fill(dp[i], Integer.MAX_VALUE); &#125; for (int i : pos[key.charAt(0) - &#x27;a&#x27;]) &#123; dp[0][i] = Math.min(i, n - i) + 1; &#125; for (int i = 1; i &lt; m; ++i) &#123; for (int j : pos[key.charAt(i) - &#x27;a&#x27;]) &#123; for (int k : pos[key.charAt(i - 1) - &#x27;a&#x27;]) &#123; dp[i][j] = Math.min(dp[i][j], dp[i - 1][k] + Math.min(Math.abs(j - k), n - Math.abs(j - k)) + 1); &#125; &#125; &#125; return Arrays.stream(dp[m - 1]).min().getAsInt(); &#125;&#125; 时间复杂度是$O(mn^2)$ 空间复杂度是$O(mn)$","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"动态规划","slug":"LeetCode刷题/动态规划","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"hard","slug":"LeetCode刷题/动态规划/hard","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/hard/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://jums.club/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"hard","slug":"hard","permalink":"http://jums.club/tags/hard/"},{"name":"动态规划","slug":"动态规划","permalink":"http://jums.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"打家劫舍","slug":"house-robber","date":"2020-11-12T02:33:54.000Z","updated":"2020-11-12T12:38:37.178Z","comments":true,"path":"house-robber/","link":"","permalink":"http://jums.club/house-robber/","excerpt":"198. 打家劫舍https://leetcode-cn.com/problems/house-robber/","text":"198. 打家劫舍https://leetcode-cn.com/problems/house-robber/ 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1： 输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。示例 2： 输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 提示： 0 &lt;= nums.length &lt;= 1000 &lt;= nums[i] &lt;= 400 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/house-robber著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 1 解题思路劫匪遇到一间屋子，有两种选择，一是打劫，二是不打劫。如果打劫，则需要第$i-1$个屋子没有被打劫，也就是说，第$i-1$个屋子不能被算到总的金额中。如果不打劫，则打劫到当前屋子的最高金额就是打劫到第$i-1$个屋子所能获得的最高金额。 定义一个$dp$数组，$dp[i]$表示到第$i$个屋子为止，劫匪所能获得的最大金额，则： $dp[i]=max(dp[i-1],dp[i-2]+nums[i])$ $dp[i-1]$，表示不打劫第$i$个屋子所能获得的最大金额 $dp[i-2]+nums[i]$，表示打劫第$i$个屋子所能获得的最大金额 123456789101112131415161718class Solution &#123; public int rob(int[] nums) &#123; if (nums == null || nums.length == 0) return 0; if (nums.length == 1) return nums[0]; int[] dp = new int[nums.length]; dp[0] = nums[0]; dp[1] = Math.max(nums[0], nums[1]); for (int i = 2; i &lt; nums.length; i ++) &#123; dp[i] = Math.max( dp[i - 1], //不打劫第i个房子 dp[i - 2] + nums[i] //打劫第i个房子 ); &#125; return dp[nums.length - 1]; &#125;&#125;","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"动态规划","slug":"LeetCode刷题/动态规划","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"simple","slug":"LeetCode刷题/动态规划/simple","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/simple/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://jums.club/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"动态规划","slug":"动态规划","permalink":"http://jums.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"simple","slug":"simple","permalink":"http://jums.club/tags/simple/"}]},{"title":"922. 按奇偶排序数组 II","slug":"sort-array-by-parity-ii","date":"2020-11-12T01:52:16.000Z","updated":"2020-11-12T10:35:56.538Z","comments":true,"path":"sort-array-by-parity-ii/","link":"","permalink":"http://jums.club/sort-array-by-parity-ii/","excerpt":"922. 按奇偶排序数组 II，https://leetcode-cn.com/problems/sort-array-by-parity-ii/https://jums.club/leetcode/images/safari.png","text":"922. 按奇偶排序数组 II，https://leetcode-cn.com/problems/sort-array-by-parity-ii/https://jums.club/leetcode/images/safari.png 给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。 对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。 你可以返回任何满足上述条件的数组作为答案。 示例： 输入：[4,2,5,7]输出：[4,5,2,7]解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。 提示： 2 &lt;= A.length &lt;= 20000A.length % 2 == 00 &lt;= A[i] &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sort-array-by-parity-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 1 解题思路使用两次遍历，一次确定偶数的位置，一次确定奇数的位置。 时间复杂度是$O(n)$，空间复杂度是$O(1)$。 12345678910111213141516171819class Solution &#123; public int[] sortArrayByParityII(int[] A) &#123; int odd = 1, even = 0; int[] res = new int[A.length]; for (int a : A) &#123; if ((a &amp; 1) == 0) &#123; res[even] = a; even += 2; &#125; &#125; for (int a : A) &#123; if ((a &amp; 1) == 1) &#123; res[odd] = a; odd += 2; &#125; &#125; return res; &#125;&#125;","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"simple","slug":"LeetCode刷题/simple","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/simple/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://jums.club/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"simple","slug":"simple","permalink":"http://jums.club/tags/simple/"}]},{"title":"下一个全排列","slug":"next-permutation","date":"2020-11-10T12:19:06.000Z","updated":"2020-11-12T12:38:00.794Z","comments":true,"path":"next-permutation/","link":"","permalink":"http://jums.club/next-permutation/","excerpt":"","text":"31. 下一个排列https://leetcode-cn.com/problems/next-permutation/ 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/next-permutation著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解释思路从后往前遍历数组，找到第一个小于当前索引位置的数，假设当前索引是$i$，则找到$i-1$，有以下三种情况： 1.$i==nums.length$，说明数组是一个升序数组，直接交换$nums[i]$和$nums[i-1]$的位置即可，如$123$-&gt;$132$ 2.$0&lt;i&lt;nums.length$，说明这样的数在数组中间，直接从第$[i…nums.length]$的数中找到一个大于且仅大于$nums[i-1]$的数，即这个数是$[i…nums.length]$中大于$nums[i-1]$中最小的，假设该索引是$min$，然后交换$nums[i-1]$和$nums[min]$的值，并将$[i…nums.length]$中的所有数进行升序排序，便是最终答案 3.$i==0$，说明数组是一个倒序的数组，直接将数组$reverse$即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123; public void nextPermutation(int[] nums) &#123; if (nums.length == 1) return; int i = nums.length - 1; for (; i &gt; 0; i--) &#123; if (nums[i] &lt;= nums[i - 1]) continue; //12345 -&gt; 12354 if (i == nums.length - 1) &#123; nums[i] = nums[i - 1] ^ nums[i]; nums[i - 1] = nums[i - 1] ^ nums[i]; nums[i] = nums[i - 1] ^ nums[i]; return; &#125; int min = i; //从[i,nums.length-1]的闭区间中找到一个大于nums[i - 1]的最小的值，并与nums[i - 1]交换 for (int j = nums.length - 1; j &gt;= i; j--) &#123; if (nums[j] &gt; nums[i - 1] &amp;&amp; nums[j] &lt; nums[min]) min = j; &#125; nums[i- 1] = nums[i - 1] ^ nums[min]; nums[min] = nums[i - 1] ^ nums[min]; nums[i- 1] = nums[i - 1] ^ nums[min]; //将第i个位置以后的数字进行升序排序 for (int j = i; j &lt; nums.length - 1; j++) &#123; for (int k = i; k &lt; nums.length - 1; k++) &#123; if (nums[k] &gt; nums[k + 1]) &#123; nums[k] = nums[k] ^ nums[k + 1]; nums[k + 1] = nums[k] ^ nums[k + 1]; nums[k] = nums[k] ^ nums[k + 1]; &#125; &#125; &#125; return; &#125; //倒序数组 int l = 0, r = nums.length - 1; while (l &lt; r) &#123; nums[l] = nums[l] ^ nums[r]; nums[r] = nums[l] ^ nums[r]; nums[l] = nums[l] ^ nums[r]; l ++; r --; &#125; &#125;&#125;","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"排序算法","slug":"LeetCode刷题/排序算法","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"middle","slug":"LeetCode刷题/排序算法/middle","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/middle/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://jums.club/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"middle","slug":"middle","permalink":"http://jums.club/tags/middle/"},{"name":"排序算法","slug":"排序算法","permalink":"http://jums.club/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}]},{"title":"二分搜索","slug":"binary-search","date":"2020-11-10T07:33:01.000Z","updated":"2020-11-10T10:52:51.657Z","comments":true,"path":"binary-search/","link":"","permalink":"http://jums.club/binary-search/","excerpt":"1 时间复杂度二分查找的思想很简单，前提是数组是有序的，查找的时间复杂度是$O(logn)$。利用三个指针，分别指向数组的头部、中间和尾部，如果待查找的元素$target$在数组的前半部分，则跳转到前半部分查找，如果在后半部分，则跳转到后半部分进行查找，当头部的值大于尾部指针的值时，则表示查不到。","text":"1 时间复杂度二分查找的思想很简单，前提是数组是有序的，查找的时间复杂度是$O(logn)$。利用三个指针，分别指向数组的头部、中间和尾部，如果待查找的元素$target$在数组的前半部分，则跳转到前半部分查找，如果在后半部分，则跳转到后半部分进行查找，当头部的值大于尾部指针的值时，则表示查不到。 2 关键代码12345678910111213public boolean binarySearch(int []nums, int target)&#123; int l = 0, r = nums.length-1; while(l&lt;=r)&#123; int mid = l + (r-l)/2; if(nums[mid] == target) return true; else if(nums[mid] &lt; target)//到后半部分查找 l = mid + 1; else r = mid - 1;//到前半部分查找 如果第3行中用的是while(l&lt;r)，则此行应该写成开区间，即r=mid; &#125; return false;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://jums.club/categories/%E7%AE%97%E6%B3%95/"},{"name":"搜索算法","slug":"算法/搜索算法","permalink":"http://jums.club/categories/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://jums.club/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索算法","slug":"搜索算法","permalink":"http://jums.club/tags/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"树","slug":"LeetCode刷题/树","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E6%A0%91/"},{"name":"simple","slug":"LeetCode刷题/树/simple","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E6%A0%91/simple/"},{"name":"动态规划","slug":"LeetCode刷题/动态规划","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"hard","slug":"LeetCode刷题/动态规划/hard","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/hard/"},{"name":"算法总结","slug":"LeetCode刷题/算法总结","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"name":"回溯法","slug":"LeetCode刷题/算法总结/回溯法","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E5%9B%9E%E6%BA%AF%E6%B3%95/"},{"name":"面试算法题","slug":"面试算法题","permalink":"http://jums.club/categories/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"大厂","slug":"面试算法题/大厂","permalink":"http://jums.club/categories/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/%E5%A4%A7%E5%8E%82/"},{"name":"链表","slug":"LeetCode刷题/链表","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/"},{"name":"middle","slug":"LeetCode刷题/链表/middle","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/middle/"},{"name":"算法题","slug":"算法题","permalink":"http://jums.club/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"双指针","slug":"LeetCode刷题/双指针","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"middle","slug":"LeetCode刷题/双指针/middle","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E5%8F%8C%E6%8C%87%E9%92%88/middle/"},{"name":"middle","slug":"LeetCode刷题/middle","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/middle/"},{"name":"双指针","slug":"LeetCode刷题/middle/双指针","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/middle/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"simple","slug":"LeetCode刷题/动态规划/simple","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/simple/"},{"name":"simple","slug":"LeetCode刷题/simple","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/simple/"},{"name":"排序算法","slug":"LeetCode刷题/排序算法","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"middle","slug":"LeetCode刷题/排序算法/middle","permalink":"http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/middle/"},{"name":"算法","slug":"算法","permalink":"http://jums.club/categories/%E7%AE%97%E6%B3%95/"},{"name":"搜索算法","slug":"算法/搜索算法","permalink":"http://jums.club/categories/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://jums.club/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"simple","slug":"simple","permalink":"http://jums.club/tags/simple/"},{"name":"树","slug":"树","permalink":"http://jums.club/tags/%E6%A0%91/"},{"name":"hard","slug":"hard","permalink":"http://jums.club/tags/hard/"},{"name":"动态规划","slug":"动态规划","permalink":"http://jums.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"算法总结","slug":"算法总结","permalink":"http://jums.club/tags/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"name":"回溯法","slug":"回溯法","permalink":"http://jums.club/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"},{"name":"面试算法题","slug":"面试算法题","permalink":"http://jums.club/tags/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"大厂","slug":"大厂","permalink":"http://jums.club/tags/%E5%A4%A7%E5%8E%82/"},{"name":"middle","slug":"middle","permalink":"http://jums.club/tags/middle/"},{"name":"链表","slug":"链表","permalink":"http://jums.club/tags/%E9%93%BE%E8%A1%A8/"},{"name":"算法题","slug":"算法题","permalink":"http://jums.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"双指针","slug":"双指针","permalink":"http://jums.club/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"排序算法","slug":"排序算法","permalink":"http://jums.club/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"算法","slug":"算法","permalink":"http://jums.club/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索算法","slug":"搜索算法","permalink":"http://jums.club/tags/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"}]}