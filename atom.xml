<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Crazyjums Leetcode</title>
  
  <subtitle>Pary For A Good Life</subtitle>
  <link href="http://jums.club/atom.xml" rel="self"/>
  
  <link href="http://jums.club/"/>
  <updated>2020-11-24T08:30:20.509Z</updated>
  <id>http://jums.club/</id>
  
  <author>
    <name>Crazy Jums</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指 Offer 54. 二叉搜索树的第 k 大节点</title>
    <link href="http://jums.club/kthlargest/"/>
    <id>http://jums.club/kthlargest/</id>
    <published>2020-11-24T08:28:16.000Z</published>
    <updated>2020-11-24T08:30:20.509Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\leetcode\assets\css\APlayer.min.css"><script src="\leetcode\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="tag link"><a class="link-card" title="剑指 Offer 54. 二叉搜索树的第k大节点" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/"><div class="left"><img src="https://jums.club/leetcode/images/safari.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/safari.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">剑指 Offer 54. 二叉搜索树的第k大节点</p><p class="url">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/</p></div></a></div><a id="more"></a><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1 题目"></a>1 题目</h2><blockquote><p>给定一棵二叉搜索树，请找出其中第k大的节点。<br>示例 1:</p><p>输入: root = [3,1,4,null,2], k = 1<br>&nbsp;  &nbsp; 3<br>&nbsp;  / &nbsp; \<br>1 &nbsp; &nbsp;   4<br>&nbsp;    \<br>  &nbsp; &nbsp;    2<br>输出: 4<br>示例2:</p><p>输入: root = [5,3,6,2,4,null,null,1], k = 3<br>&nbsp;    &nbsp;  5<br>&nbsp;    / &nbsp; \<br>  &nbsp; 3  &nbsp;  6<br> &nbsp; / \<br>2 &nbsp;   4<br>    /<br>   1<br> 输出: 4  </p><p>限制：</p><p>1 ≤ k ≤ 二叉搜索树元素个数</p><p>作者：画手大鹏<br>链接：<a href="https://leetcode-cn.com/leetbook/read/illustrate-lcof/xspy85/">https://leetcode-cn.com/leetbook/read/illustrate-lcof/xspy85/</a><br>来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><h2 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2 中序遍历"></a>2 中序遍历</h2><p>该方法为先使用一个集合类容器放置该树的中序遍历的结果序列，因为二叉搜索树的中序遍历是一个升序的序列，那么第$k$大的数则为第$list.size()-k$个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inOrder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res.get(res.size() - k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        inOrder(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种算法的时间复杂度和空间复杂度都是$O(n)$，其中$n$是二叉搜索树的节点个数，那么这种方法并没有利用二叉搜索树的性质。</p><h2 id="3-改进版"><a href="#3-改进版" class="headerlink" title="3 改进版"></a>3 改进版</h2><p>我们知道二叉搜索树的左子树的所有值都小于根节点的值，右子树的所有值都大于根节点的值。且中序遍历的序列是一个升序的序列，那么中序遍历的顺序是<code>left</code>-&gt;<code>root</code>-&gt;<code>right</code>。这种遍历方式决定了中序遍历的结果是一个升序的序列，题目中要求返回第$k$大的数，那么就是中序遍历序列从后往后算起第$k$个数。<br>我们可以不用遍历完这棵树，只需要遍历$k$次即可，我们修改树的遍历次序，改为<code>right</code>-&gt;<code>root</code>-<code>left</code>。那么遍历的最终的结果就是一个降序的序列。我们定义一个全局的索引，判断当前遍历到了第几个节点，当遍历到第$k$个节点时，我们就可以结束遍历返回结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.index = k;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        dfs(root.right);</span><br><span class="line">        index--;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            res = root.val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;剑指 Offer 54. 二叉搜索树的第k大节点&quot; href=&quot;https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/&quot;&gt;&lt;div class=&quot;left&quot;&gt;&lt;img src=&quot;https://jums.club/leetcode/images/safari.png&quot;/&gt;&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;p class=&quot;text&quot;&gt;剑指 Offer 54. 二叉搜索树的第k大节点&lt;/p&gt;&lt;p class=&quot;url&quot;&gt;https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/&lt;/p&gt;&lt;/div&gt;&lt;/a&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="LeetCode刷题" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    <category term="树" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E6%A0%91/"/>
    
    <category term="simple" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E6%A0%91/simple/"/>
    
    
    <category term="LeetCode刷题" scheme="http://jums.club/tags/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    <category term="simple" scheme="http://jums.club/tags/simple/"/>
    
    <category term="树" scheme="http://jums.club/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 28. 对称的二叉树</title>
    <link href="http://jums.club/mirror-tree/"/>
    <id>http://jums.club/mirror-tree/</id>
    <published>2020-11-24T07:59:00.000Z</published>
    <updated>2020-11-24T08:02:02.547Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\leetcode\assets\css\APlayer.min.css"><script src="\leetcode\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="tag link"><a class="link-card" title="剑指 Offer 28. 对称的二叉树" href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/"><div class="left"><img src="https://jums.club/leetcode/images/safari.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/safari.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">剑指 Offer 28. 对称的二叉树</p><p class="url">https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/</p></div></a></div><a id="more"></a><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1 题目"></a>1 题目</h2><blockquote><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。<br>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。<br>   1<br>   / \<br> 2   2<br> / \ / \<br>3  4 4  3<br>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:<br>   1<br>  / \<br> 2    2<br>  \       \<br> 3       3<br>示例 1：<br>输入：root = [1,2,2,3,4,4,3]<br>输出：true<br>示例 2：<br>输入：root = [1,2,2,null,3,null,3]<br>输出：false<br>限制：<br>0 &lt;= 节点个数 &lt;= 1000<br>注意：本题与主站 101 题相同：<a href="https://leetcode-cn.com/problems/symmetric-tree/">https://leetcode-cn.com/problems/symmetric-tree/</a><br>作者：画手大鹏<br>链接：<a href="https://leetcode-cn.com/leetbook/read/illustrate-lcof/xsrxq1/">https://leetcode-cn.com/leetbook/read/illustrate-lcof/xsrxq1/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><h2 id="2-深度优先搜索"><a href="#2-深度优先搜索" class="headerlink" title="2 深度优先搜索"></a>2 深度优先搜索</h2><p>有以下几种情况：</p><ul><li><p>左子树为空，右子树也为空  $true$</p></li><li><p>左子树为空，右子树不为空 $false$</p></li><li><p>左子树不为空，右子树为空，$false$</p></li><li><p>左子树不为空，右子树也不为空，进行进一步的判断</p><ul><li>左子树的值等于右子树的值，继续判断。如果所有的左右子树都满足这一条，则是$true$</li><li>左右子树的值不相等，$false$</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(root, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> || right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//这里不能用else，如果用了else，那么后面的return语句就不能被执行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (left.val == right.val) </span><br><span class="line">        &amp;&amp; dfs(left.left, right.right) </span><br><span class="line">        &amp;&amp; dfs(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-广度优先搜索"><a href="#3-广度优先搜索" class="headerlink" title="3 广度优先搜索"></a>3 广度优先搜索</h2><p>判断思路与上面的深度优先搜索的思路相同，只不过这里使用广度优先搜索的方法进行求解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || (root.left == <span class="keyword">null</span> &amp;&amp;root.right == <span class="keyword">null</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.add(root.left);</span><br><span class="line">        q.add(root.right);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            TreeNode l = q.poll();</span><br><span class="line">            TreeNode r = q.poll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (l == <span class="keyword">null</span> &amp;&amp; r == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">//这里不能直接返回true，应该继续判断，知道整棵二叉树都满足该特点</span></span><br><span class="line">            <span class="keyword">if</span> (l == <span class="keyword">null</span> || r == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (l.val != r.val)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">            q.add(l.left);</span><br><span class="line">            q.add(r.right);</span><br><span class="line"></span><br><span class="line">            q.add(l.right);</span><br><span class="line">            q.add(r.left);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;剑指 Offer 28. 对称的二叉树&quot; href=&quot;https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/&quot;&gt;&lt;div class=&quot;left&quot;&gt;&lt;img src=&quot;https://jums.club/leetcode/images/safari.png&quot;/&gt;&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;p class=&quot;text&quot;&gt;剑指 Offer 28. 对称的二叉树&lt;/p&gt;&lt;p class=&quot;url&quot;&gt;https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/&lt;/p&gt;&lt;/div&gt;&lt;/a&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="LeetCode刷题" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    <category term="树" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E6%A0%91/"/>
    
    <category term="simple" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E6%A0%91/simple/"/>
    
    
    <category term="LeetCode刷题" scheme="http://jums.club/tags/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    <category term="simple" scheme="http://jums.club/tags/simple/"/>
    
    <category term="树" scheme="http://jums.club/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 19. 正则表达式匹配</title>
    <link href="http://jums.club/is-match-1/"/>
    <id>http://jums.club/is-match-1/</id>
    <published>2020-11-23T11:28:40.000Z</published>
    <updated>2020-11-23T11:30:56.620Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\leetcode\assets\css\APlayer.min.css"><script src="\leetcode\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="tag link"><a class="link-card" title="剑指 Offer 19. 正则表达式匹配" href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/"><div class="left"><img src="https://jums.club/leetcode/images/safari.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/safari.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">剑指 Offer 19. 正则表达式匹配</p><p class="url">https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/</p></div></a></div><a id="more"></a><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1 题目"></a>1 题目</h2><blockquote><p>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p><p>示例 1:</p><p>输入:<br>s = “aa”<br>p = “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。<br>示例 2:</p><p>输入:<br>s = “aa”<br>p = “a*”<br>输出: true<br>解释: 因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。<br>示例 3:</p><p>输入:<br>s = “ab”<br>p = “.<em>“<br>输出: true<br>解释: “.</em>“ 表示可匹配零个或多个（’*’）任意字符（’.’）。<br>示例 4:</p><p>输入:<br>s = “aab”<br>p = “c<em>a</em>b”<br>输出: true<br>解释: 因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。<br>示例 5:</p><p>输入:<br>s = “mississippi”<br>p = “mis<em>is</em>p*.”<br>输出: false<br>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 <em>，无连续的 ‘</em>‘。<br>注意：本题与主站 10 题相同：<a href="https://leetcode-cn.com/problems/regular-expression-matching/">https://leetcode-cn.com/problems/regular-expression-matching/</a></p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof">https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2 分析"></a>2 <a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/zhu-xing-xiang-xi-jiang-jie-you-qian-ru-shen-by-je/">分析</a></h2><p>使用正则表达式进行求解。将两个字符串从后往前进行比较，其中模式串的最后一个字符可能由一下三种情况：</p><ul><li>正常字符（[a-zA-Z]）</li><li>星号（*）</li><li>点号（.）</li></ul><p>定义主串为$s$，长度为$m$，模式串为$p$，长度为$n$。则有一下三种情况：</p><ol><li>$p[n - 1]$为一个正常字符，则此时只能将模式串的最后一个字符和主串的最后一个字符进行比较，如果模式串的最后一个字符等于主串的最后一个字符（$p[n - 1] == s[m-1]$），则继续判断$p[n-2]$是否等于$s[m-2]$，以此类推。</li><li>$p[n-1]==’.’$。因为题目中说，$’.’$可以匹配任何一个字符，所以模式串和主串的最后一个就相当于匹配上了，继续匹配$p[n-2]$和$s[m-2]$。</li><li>$p[n-1]==’<em>‘$。题目中说$’</em>‘$可以匹配$’*’$号之前的那个字符任意多次（包括0次），假设$p[n-2]==c$，则主串中的字符可以匹配$c$0次或者多次：<ol><li>匹配0次。那么模式串的最后两个字符就可以不用看了，因为主串被匹配了0次。比如：$s=”abc”$，$p=”abcd*”$，可将$p$的倒数第二个字符$d$认为匹配了0次，所以主串和模式串可以匹配。</li><li>匹配了多次。此种情况必须满足$s[m-1]==c$或者$c=’.’$，否则将不能匹配多次。比如：$s=”abc”$，$p=”abc*”$，可以认为字符$’c’$匹配了1次；或者$s=”abc”$，$p=”ab.*”$，此时两个串也可以匹配上。</li></ol></li></ol><p>上面将所有的可能情况都列举了，那么此时只需要定义一个$dp$数组即可，其中$dp[i][j]$表示$s$串的前$i$个字符和$p$串的前$j$个字符能否匹配。此时又分成以下4中情况：</p><ol><li>主串为空，模式串也为空，那么此时一定可以匹配</li><li>主串为空，模式串不为空，此时不能直接得出结果，必须通过计算得出，比如$s=””$，$p=”a<em>b</em>c*”$，此种情况两个串可以匹配。</li><li>主串不为空，模式串为空，此时一定不能匹配。</li><li>主串不为空，模式串也不为空，那么此时就需要计算得出结果</li></ol><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length();</span><br><span class="line">        <span class="keyword">int</span> n = p.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义dp数组，dp[i][j]表示s串的前i个字符和p串的前j个字符是否匹配</span></span><br><span class="line"><span class="comment">        有一下四种情况：</span></span><br><span class="line"><span class="comment">            1. 主串为空， 模式串也为空， 此种情况可以匹配</span></span><br><span class="line"><span class="comment">            2. 主串为空， 模式串为非空， 此种情况不能直接判断是否能匹配，需要计算</span></span><br><span class="line"><span class="comment">            3. 主串非空， 模式为空， 此时一定不能匹配</span></span><br><span class="line"><span class="comment">            4. 主串和模式串都是非空， 此时需要计算</span></span><br><span class="line"><span class="comment">                计算规则如下：从后往前匹配，可以将一个大的问题转化为一个子问题</span></span><br><span class="line"><span class="comment">                模式串的最后一个字符有三种可能：正常字符，星号（*），点（.）</span></span><br><span class="line"><span class="comment">                1. 如果p的最后一个字符是正常字符，则判断：</span></span><br><span class="line"><span class="comment">                    - p[n - 1] == s[m - 1]，则继续匹配s和p的倒数第二个字符 dp[i][j] = dp[i - 1][j - 1]</span></span><br><span class="line"><span class="comment">                    - p[n - 1] != s[m - 1]，则说明最后一个字符不匹配 dp[i][j] = false</span></span><br><span class="line"><span class="comment">                2. 如果p的最后一个字符是&quot;.&quot;，说明可以匹配任何字符，此时继续匹配倒数第二个字符  dp[i][j] = dp[i - 1][j - 1]</span></span><br><span class="line"><span class="comment">                3. 如果p的最后一个字符是“*”，表示“*”之前的一个字符（p[n - 1] = c）可以出现0次或多次，</span></span><br><span class="line"><span class="comment">                    - 出现0次：即表示p串的最后两个字符可以不用比较，直接比较s[n - 1]和p[n - 3]，dp[i][j] = dp[i][j - 2]</span></span><br><span class="line"><span class="comment">                    - 出现多次：此种情况下，要求s[m - 1] == p[n- 1] || p[n - 1] == &#x27;.&#x27;，模式串不动，主串继续向前移动。</span></span><br><span class="line"><span class="comment">                     dp[i][j] = [i - 1][j]</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// for (int i = 1; i &lt; n; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     dp[0][i] = false;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) <span class="comment">//主串</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123; <span class="comment">//模式匹配串</span></span><br><span class="line">                <span class="comment">//如果模式串是空串</span></span><br><span class="line">                <span class="comment">//1.主串为空， 模式串也为空， 此种情况可以匹配</span></span><br><span class="line">                <span class="comment">//2.主串非空， 模式为空， 此时一定不能匹配</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = i == <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// char ch = p.charAt(j - 1);</span></span><br><span class="line">                    <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) != <span class="string">&#x27;*&#x27;</span>) &#123; <span class="comment">//将正常字符和“.”合并处理</span></span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>) || p.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                            dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//出现0次</span></span><br><span class="line">                        <span class="keyword">if</span> (j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                            dp[i][j] = dp[i][j - <span class="number">2</span>];</span><br><span class="line">                        &#125; </span><br><span class="line">                        <span class="comment">//出现多次</span></span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        关于为什么用|=，比如这段代码： //碰到 * 了，</span></span><br><span class="line"><span class="comment">                        分为看和不看两种情况 //不看 if (j &gt;= 2) &#123; f[i][j] |= f[i][j - 2]; </span></span><br><span class="line"><span class="comment">                        //可用可不用，因为dp矩阵初始化默认为false，本质上和=一样 &#125; </span></span><br><span class="line"><span class="comment">                        //看 if (i &gt;= 1 &amp;&amp; j &gt;= 2 </span></span><br><span class="line"><span class="comment">                        &amp;&amp; (A.charAt(i - 1) == B.charAt(j - 2) || B.charAt(j - 2) == &#x27;.&#x27;)) &#123; f[i][j] |= f[i - 1][j]; </span></span><br><span class="line"><span class="comment">                        //必须使用，否则不能ac &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                        其中，第一步先算的是不看‘*’的情况，然后第二步再算看‘*’的情况。</span></span><br><span class="line"><span class="comment">                        也就是说，对于f[i][j]我们会算两次。如果在第一次，即不看&#x27;*&#x27;的时候，</span></span><br><span class="line"><span class="comment">                        就已经算出来TURE了。那在第二步看&#x27;*&#x27;的时候。不管结果是ture还是false，</span></span><br><span class="line"><span class="comment">                        都保持true不变，这是合理的，因为只要其中有一种情况能完整匹配，结果就为true。</span></span><br><span class="line"><span class="comment">                        这就是为什么要用或符号。 这个不难证明，举个例子 &quot;ba&quot; &quot;baa*&quot; 这种情况下直接用=号过不了。</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                        <span class="keyword">if</span> (i &gt;=<span class="number">1</span> &amp;&amp; j &gt;= <span class="number">2</span> &amp;&amp; (s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">2</span>) || p.charAt(j - <span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                            dp[i][j] |= dp[i - <span class="number">1</span>][j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;剑指 Offer 19. 正则表达式匹配&quot; href=&quot;https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/&quot;&gt;&lt;div class=&quot;left&quot;&gt;&lt;img src=&quot;https://jums.club/leetcode/images/safari.png&quot;/&gt;&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;p class=&quot;text&quot;&gt;剑指 Offer 19. 正则表达式匹配&lt;/p&gt;&lt;p class=&quot;url&quot;&gt;https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/&lt;/p&gt;&lt;/div&gt;&lt;/a&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="LeetCode刷题" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    <category term="动态规划" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="hard" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/hard/"/>
    
    
    <category term="LeetCode刷题" scheme="http://jums.club/tags/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    <category term="hard" scheme="http://jums.club/tags/hard/"/>
    
    <category term="动态规划" scheme="http://jums.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>6道回溯算法题，了解以及掌握回溯法的基本套路</title>
    <link href="http://jums.club/back-tracks/"/>
    <id>http://jums.club/back-tracks/</id>
    <published>2020-11-15T06:56:13.000Z</published>
    <updated>2020-11-15T12:21:41.173Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\leetcode\assets\css\APlayer.min.css"><script src="\leetcode\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="tag link"><a class="link-card" title="46. 全排列" href="https://leetcode-cn.com/problems/permutations/"><div class="left"><img src="https://jums.club/leetcode/images/safari.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/safari.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">46. 全排列</p><p class="url">https://leetcode-cn.com/problems/permutations/</p></div></a></div><a id="more"></a><div class="tag link"><a class="link-card" title="46. 全排列" href="https://leetcode-cn.com/problems/permutations/"><div class="left"><img src="https://jums.club/leetcode/images/safari.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/safari.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">46. 全排列</p><p class="url">https://leetcode-cn.com/problems/permutations/</p></div></a></div><div class="tag link"><a class="link-card" title="47. 全排列 IIhttps://leetcode-cn.com/problems/permutations-ii/" href="https://jums.club/leetcode/images/safari.png"><div class="left"><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">47. 全排列 IIhttps://leetcode-cn.com/problems/permutations-ii/</p><p class="url">https://jums.club/leetcode/images/safari.png</p></div></a></div><div class="tag link"><a class="link-card" title="78. 子集" href="https://leetcode-cn.com/problems/subsets/"><div class="left"><img src="https://jums.club/leetcode/images/safari.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/safari.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">78. 子集</p><p class="url">https://leetcode-cn.com/problems/subsets/</p></div></a></div><div class="tag link"><a class="link-card" title="90. 子集 II" href="https://leetcode-cn.com/problems/subsets-ii/)"><div class="left"><img src="https://jums.club/leetcode/images/safari.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/safari.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">90. 子集 II</p><p class="url">https://leetcode-cn.com/problems/subsets-ii/)</p></div></a></div><div class="tag link"><a class="link-card" title="39. 组合总和" href="https://leetcode-cn.com/problems/combination-sum/"><div class="left"><img src="https://jums.club/leetcode/images/safari.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/safari.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">39. 组合总和</p><p class="url">https://leetcode-cn.com/problems/combination-sum/</p></div></a></div><div class="tag link"><a class="link-card" title="40. 组合总和 II" href="https://leetcode-cn.com/problems/combination-sum-ii/"><div class="left"><img src="https://jums.club/leetcode/images/safari.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/safari.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">40. 组合总和 II</p><p class="url">https://leetcode-cn.com/problems/combination-sum-ii/</p></div></a></div><h2 id="1-使用回溯算法求46-全排列"><a href="#1-使用回溯算法求46-全排列" class="headerlink" title="1 使用回溯算法求46. 全排列"></a>1 使用回溯算法求<a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h2><blockquote><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p><p>示例:</p><p>输入: [1,2,3]<br>输出:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p></blockquote><p>这是一道金典的回溯算法题，使用回溯法进行求解，我们通过在这道题来了解什么是回溯，以及掌握回溯算法的套路。回溯即重新回过头去看的意思，也就是说使用该方法进行求解时，需要不时的回头看看，我们可以画出该题的回溯树，从下面的回溯树可以看出，回溯法的求解过程类似于深度优先搜索。这里需要注意几个地方，即数组中的元素用过一次之后，不能再之后的选择中再次出现。比如第一个分支，选择了$1$之后，后面的两个分支就只能选择$2$或者$3$。其他两个分支也是类似，那么就需要一个有这么一个数据结构能够记录当前所做出的选择，并在回溯之后撤销当前所做的选择。这里我们可以使用一个相同大小的数组即可，每次做出选择时，在相同的下标位置做上标记，当回溯到上一层时，消除标记，为了判断时方便，这里使用$boolean$型数组。</p><img src="https://jums.club/leetcode/images/1.jpg" class="lazyload" data-srcset="https://jums.club/leetcode/images/1.jpg" srcset="data:image/png;base64,666" style="zoom: 50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length]; <span class="comment">//也可以使用int或者其他类型的数组，只要能标记就行</span></span><br><span class="line">        dfs(used, res, path, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[] used, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line">                dfs(used, res, path, nums);</span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-回溯算法的解题模板"><a href="#2-回溯算法的解题模板" class="headerlink" title="2 回溯算法的解题模板"></a>2 回溯算法的解题模板</h2><p>通过上面的题，我们应该能大概知道回溯算法的一个解题思路，通常遇到一道回溯算法题时，首先应该在抄稿纸上画出该题的回溯树，如果需要剪枝的话，还需要进行剪枝操作，这里我们可以通过<a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a>这一题了解回溯法的剪枝过程。回溯算法的大致模板如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();  <span class="comment">//1、定义结果集的容器</span></span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123; <span class="comment">//2、判断条件下的结果</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//3、定义单个的回溯路径容器</span></span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length]; <span class="comment">//4、定义标记数据结构，用于防止重复访问，这是非必要</span></span><br><span class="line">        dfs(used, res, path, nums); <span class="comment">//5、进入回溯算法的递归树中</span></span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">//返回最终结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[] used, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) &#123; <span class="comment">// 1、定义递归的退出条件，必须有 当回溯路径中取到所有选择时，则添加到结果集并退出递归</span></span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 必须要返回</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123; <span class="comment">// 2、当前逻辑  即做出选择，一共有多少种选择</span></span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123; <span class="comment">//该步是判断当前的元素是否已经被选择过，如果没有，则需要进一步做选择，否则跳过</span></span><br><span class="line">                path.add(nums[i]); <span class="comment">//3、将当前的选择添加到回溯分支中</span></span><br><span class="line">                used[i] = <span class="keyword">true</span>; <span class="comment">//并标记当前选择已经被选择过，在当前的回溯分支中该元素不能再被重新选择</span></span><br><span class="line">                dfs(used, res, path, nums); <span class="comment">// 4、当前选择已经做好了，继续向下左选择，进入下一个回溯分支</span></span><br><span class="line">                used[i] = <span class="keyword">false</span>; <span class="comment">//5、如果下一个分支到头了，即到了回溯树的叶子节点处，此时即找到了一个结果，将其添加到结果集中，并向上回溯一层，即撤销当前的选择，慢慢想回溯树的根部移动，回溯到上一层后，需要撤销当前所做的选择</span></span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>); <span class="comment">//回溯一层后，需要将当前的回溯分支的叶子部分进行删除</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是在<a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a>的代码基础上进行的一个分析，下面给出一个抽象的模板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> 结果集容器 方法名(选择列表) &#123;</span><br><span class="line">        <span class="number">1</span>、定义结果集容器;</span><br><span class="line">        <span class="number">2</span>、判断特殊情况下的结果;</span><br><span class="line">        <span class="number">3</span>、定义一个存放回溯分支的容器;</span><br><span class="line">        <span class="number">4</span>、进入回溯函数，这里定义为backTrack();</span><br><span class="line">        <span class="keyword">return</span> res;   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(res, path, nums)</span> </span>&#123;</span><br><span class="line">        <span class="number">1</span>、递归退出条件;</span><br><span class="line">        </span><br><span class="line">        <span class="number">2</span>、定义当前逻辑;</span><br><span class="line">        <span class="keyword">for</span> (num : nums) &#123; <span class="comment">//列出所有的可能选择</span></span><br><span class="line">            <span class="comment">//如果需要，可以判断当前选择是否在之前已经被选择过;</span></span><br><span class="line">            path.add(num); <span class="comment">//将当前的选择添加到回溯的分支中，当前选择必须是可以被选择的一个选择</span></span><br><span class="line">            <span class="comment">//继续进入下一层的回溯分支</span></span><br><span class="line">            backTrack(res, path, nums);</span><br><span class="line">            <span class="comment">//撤销上一层所做的选择，</span></span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-回溯算法的剪枝-47-全排列-II"><a href="#3-回溯算法的剪枝-47-全排列-II" class="headerlink" title="3 回溯算法的剪枝-47. 全排列 II"></a>3 回溯算法的剪枝-<a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></h2><blockquote><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p><p>示例:</p><p>输入: [1,2,3]<br>输出:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p></blockquote><p>该题是在全排列的基础上进行了改进，这里的选择中可能会出现重复的元素，但是结果集中不能有重复的解，那么使用上一题的解法定义一个标记数组来解这道题的话，也可以解出来，然后在添加到结果集中时判断一下当前的回溯分支是否已经在结果集中，如果不在，则添加，否则不添加，但是这样会出很多的无畏的操作，导致算法的时间复杂度很高。</p><ul><li>在添加到结果集中之前，需要判断当前的回溯分支是否在结果集中，这一步的时间复杂度是$O(n)$</li><li>由于回溯树做了很多无畏的计算，那么这一步的最坏的时间复杂度是$O(2^n)$</li></ul><p>下图来自<a href="https://leetcode-cn.com/problems/permutations-ii/solution/hot-100-47quan-pai-lie-ii-python3-hui-su-kao-lu-zh/">力扣题解</a>。</p><p><img src="https://jums.club/leetcode/images/411c88e56c5538a787b4bd4c86d433f00a461d93c0af8ca3a74d7bed41055c34-image.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/411c88e56c5538a787b4bd4c86d433f00a461d93c0af8ca3a74d7bed41055c34-image.png" srcset="data:image/png;base64,666"></p><p>从上图可以看出，第二层的第三个分支被剪枝了，也就是这一个分支没有参与计算，这样就大大减小了回溯树的时间复杂度。那么我们没必要在添加到总的结果集中时才判断当前回溯是否重复，我们可以可以在回溯搜索的时候就判断，即上图中的剪枝操作，我们可以先对选择数组进行<strong>排序</strong>，然后在回溯的过程中：</p><ul><li>如果是第一个待选择的选择，我们不需要判断，直接添加即可</li><li>如果是第二个待选择的选择时，先判断当前选择的前一个选择是否被选择过以及是否和当前的选择相等，如果和当前的选择相等的话，那么在往下的回溯分支就会和上一个的回溯分支重复，这就不符合题意，所以这一步跳过即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        dfs(res, path, used, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, <span class="keyword">boolean</span>[] used, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 可以将此思路当成是由nums.length个空格，从nums数组中选择数字填到这些空格中，</span></span><br><span class="line"><span class="comment">            * 从左往右，在填右边这个元素时，要先判断一下左边的元素是否被用过，如果没有被用过，那</span></span><br><span class="line"><span class="comment">            * 左边的元素是否和右边待填的元素相等，如果想等，也不能填</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123; <span class="comment">//从第二个选择开始判断是否剪枝</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line">                dfs(res, path, used, nums);</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-回溯剪枝的模板"><a href="#4-回溯剪枝的模板" class="headerlink" title="4 回溯剪枝的模板"></a>4 回溯剪枝的模板</h2><p>回溯算法的剪枝，必须对选择数组进行排序，否则不可能实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> 结果集容器 方法名(选择列表) &#123;</span><br><span class="line">        <span class="number">1</span>、定义结果集容器;</span><br><span class="line">        <span class="number">2</span>、判断特殊情况下的结果;</span><br><span class="line">        <span class="number">3</span>、定义一个存放回溯分支的容器;</span><br><span class="line">        <span class="number">4</span>、进入回溯函数，这里定义为backTrack();</span><br><span class="line">        <span class="keyword">return</span> res;   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(res, path, nums)</span> </span>&#123;</span><br><span class="line">        <span class="number">1</span>、递归退出条件;</span><br><span class="line">        </span><br><span class="line">        <span class="number">2</span>、定义当前逻辑;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123; <span class="comment">//列出所有的可能选择</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>])  <span class="comment">//从第二个选择开始判断是否剪枝</span></span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">//剪枝</span></span><br><span class="line">            <span class="comment">//如果需要，可以判断当前选择是否在之前已经被选择过;</span></span><br><span class="line">            path.add(num); <span class="comment">//将当前的选择添加到回溯的分支中，当前选择必须是可以被选择的一个选择</span></span><br><span class="line">            <span class="comment">//继续进入下一层的回溯分支</span></span><br><span class="line">            backTrack(res, path, nums);</span><br><span class="line">            <span class="comment">//撤销上一层所做的选择，</span></span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-其他与该题类似的回溯算法题"><a href="#5-其他与该题类似的回溯算法题" class="headerlink" title="5 其他与该题类似的回溯算法题"></a>5 其他与该题类似的回溯算法题</h2><div class="tag link"><a class="link-card" title="78. 子集" href="https://leetcode-cn.com/problems/subsets/"><div class="left"><img src="https://jums.club/leetcode/images/safari.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/safari.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">78. 子集</p><p class="url">https://leetcode-cn.com/problems/subsets/</p></div></a></div><p>该题除了可以使用回溯算法解题之外，还可以结合二进制和迭代进行解题。这里只列出回溯法的，有兴趣的可以自己想想怎么用二进制求解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(res, path, <span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//index表示当前查到所有选择中的第几个选择</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, <span class="keyword">int</span> index, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; index) &#123; </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path)); <span class="comment">//由于是求子集，所以是每一个回溯都是全集的自己</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            dfs(res, path, i + <span class="number">1</span>, nums);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><div class="tag link"><a class="link-card" title="90. 子集 II" href="https://leetcode-cn.com/problems/subsets-ii/)"><div class="left"><img src="https://jums.club/leetcode/images/safari.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/safari.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">90. 子集 II</p><p class="url">https://leetcode-cn.com/problems/subsets-ii/)</p></div></a></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        dfs(res, path, <span class="number">0</span>, nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, <span class="keyword">int</span> index, <span class="keyword">int</span>[] nums)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (index &gt; nums.length)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path)); <span class="comment">//同样</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; index &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            dfs(res, path, i + <span class="number">1</span>, nums);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tag link"><a class="link-card" title="39. 组合总和" href="https://leetcode-cn.com/problems/combination-sum/"><div class="left"><img src="https://jums.club/leetcode/images/safari.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/safari.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">39. 组合总和</p><p class="url">https://leetcode-cn.com/problems/combination-sum/</p></div></a></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates); <span class="comment">//排序的目的是为了剪枝</span></span><br><span class="line">        dfs(candidates, target, <span class="number">0</span>, <span class="number">0</span>, res, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> sum, <span class="keyword">int</span> index, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = sum + candidates[i];</span><br><span class="line">            <span class="keyword">if</span> (rs &lt;= target) &#123;</span><br><span class="line">                path.add(candidates[i]);</span><br><span class="line">                dfs(candidates, target, rs, i, res, path);</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//剪枝 大于target的部分可以剪枝</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tag link"><a class="link-card" title="40. 组合总和 II" href="https://leetcode-cn.com/problems/combination-sum-ii/"><div class="left"><img src="https://jums.club/leetcode/images/safari.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/safari.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">40. 组合总和 II</p><p class="url">https://leetcode-cn.com/problems/combination-sum-ii/</p></div></a></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        dfs(res, path, candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> sum, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; index &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> rs = sum + candidates[i];</span><br><span class="line">            <span class="keyword">if</span> (rs &lt;= target) &#123;</span><br><span class="line">                path.add(candidates[i]);</span><br><span class="line">                dfs(res, path, candidates, target, rs, i + <span class="number">1</span>);</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;46. 全排列&quot; href=&quot;https://leetcode-cn.com/problems/permutations/&quot;&gt;&lt;div class=&quot;left&quot;&gt;&lt;img src=&quot;https://jums.club/leetcode/images/safari.png&quot;/&gt;&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;p class=&quot;text&quot;&gt;46. 全排列&lt;/p&gt;&lt;p class=&quot;url&quot;&gt;https://leetcode-cn.com/problems/permutations/&lt;/p&gt;&lt;/div&gt;&lt;/a&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="LeetCode刷题" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    <category term="算法总结" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
    <category term="回溯法" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    
    <category term="LeetCode刷题" scheme="http://jums.club/tags/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    <category term="算法总结" scheme="http://jums.club/tags/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
    <category term="回溯法" scheme="http://jums.club/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>求只有a中函数有的元素而b中没有的元素，只有b中含有的元素而a中没有的元素</title>
    <link href="http://jums.club/two-arrays/"/>
    <id>http://jums.club/two-arrays/</id>
    <published>2020-11-14T07:44:50.000Z</published>
    <updated>2020-11-14T07:57:52.588Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\leetcode\assets\css\APlayer.min.css"><script src="\leetcode\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="tag link"><a class="link-card" title="地平线" href="https://www.horizon.ai/journey3.html"><div class="left"><img src="https://jums.club/leetcode/images/safari.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/safari.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">地平线</p><p class="url">https://www.horizon.ai/journey3.html</p></div></a></div><a id="more"></a><blockquote><p>题目：给定两个数组：求只有a中函数有的元素而b中没有的元素，只有b中含有的元素而a中没有的元素</p></blockquote><h2 id="1-解题思路"><a href="#1-解题思路" class="headerlink" title="1 解题思路"></a>1 解题思路</h2><p>这道题和<code>LeetCode</code>中的一个到题很像，<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">349. 两个数组的交集</a>，只是这里要求两个数组中互相没有的元素。思路：排序+双指针。</p><p>先给两个数组进行排序，然后定义两个指针，分别指向两个数组的开头位置，从开头开始遍历：</p><ul><li>如果两个元素相等，则指针后移，</li><li>如果不相等，<ul><li>如果$a[l1]&lt;b[l2]$，则判断$a[l1]$是否在$b$中，如果不在，则将$a[l1]$的值添加到结果集中，并$l1++$，如果在跳过</li><li>如果$a[l1]&gt;b[l2]$，则判断$b[l2]$是否在$a$中，如果不在，则将$b[l1]$的值添加到结果集中，并$l2++$，如果在跳过</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">twoArray</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    int[] a = &#123;3,4,1,2,4,4,4,5&#125;;</span></span><br><span class="line"><span class="comment">//    int[] b = &#123;5,6,3,4,5,5,5&#125;;</span></span><br><span class="line">    Arrays.sort(a);</span><br><span class="line">    Arrays.sort(b);</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; res1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; res2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l2 = <span class="number">0</span>;</span><br><span class="line">    List&lt;Integer&gt; same = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//记录a和b的相同元素</span></span><br><span class="line">    <span class="keyword">while</span> (l1 &lt; a.length &amp;&amp; l2 &lt; b.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[l1] == b[l2]) &#123;</span><br><span class="line">            same.add(a[l1]);</span><br><span class="line">            l1 ++;</span><br><span class="line">            l2 ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[l1] &lt; b[l2]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (res1.size() == <span class="number">0</span> || !same.contains(a[l1])) &#123;</span><br><span class="line">                    res1.add(a[l1]);</span><br><span class="line">                &#125;</span><br><span class="line">                l1 ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (res2.size() == <span class="number">0</span> || !same.contains(b[l2])) &#123;</span><br><span class="line">                    res2.add(b[l2]);</span><br><span class="line">                &#125;</span><br><span class="line">                l2 ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l1 &lt; a.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!same.contains(a[l1]))</span><br><span class="line">            res1.add(a[l1]);</span><br><span class="line">        l1 ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (l2 &lt; b.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!same.contains(b[l2]))</span><br><span class="line">            res2.add(b[l2]);</span><br><span class="line">        l2 ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;地平线&quot; href=&quot;https://www.horizon.ai/journey3.html&quot;&gt;&lt;div class=&quot;left&quot;&gt;&lt;img src=&quot;https://jums.club/leetcode/images/safari.png&quot;/&gt;&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;p class=&quot;text&quot;&gt;地平线&lt;/p&gt;&lt;p class=&quot;url&quot;&gt;https://www.horizon.ai/journey3.html&lt;/p&gt;&lt;/div&gt;&lt;/a&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="面试算法题" scheme="http://jums.club/categories/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="大厂" scheme="http://jums.club/categories/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/%E5%A4%A7%E5%8E%82/"/>
    
    
    <category term="面试算法题" scheme="http://jums.club/tags/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="大厂" scheme="http://jums.club/tags/%E5%A4%A7%E5%8E%82/"/>
    
  </entry>
  
  <entry>
    <title>reverse list</title>
    <link href="http://jums.club/reverse-list/"/>
    <id>http://jums.club/reverse-list/</id>
    <published>2020-11-13T11:32:32.000Z</published>
    <updated>2020-11-14T07:57:52.586Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\leetcode\assets\css\APlayer.min.css"><script src="\leetcode\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="tag link"><a class="link-card" title="31. 下一个排列" href="https://leetcode-cn.com/problems/next-permutation/"><div class="left"><img src="https://jums.club/leetcode/images/safari.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/safari.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">31. 下一个排列</p><p class="url">https://leetcode-cn.com/problems/next-permutation/</p></div></a></div><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;31. 下一个排列&quot; href=&quot;https://leetcode-cn.com/problems/next-permutation/&quot;&gt;&lt;div class=&quot;left&quot;&gt;&lt;img src=&quot;https://jums.club/leetcode/images/safari.png&quot;/&gt;&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;p class=&quot;text&quot;&gt;31. 下一个排列&lt;/p&gt;&lt;p class=&quot;url&quot;&gt;https://leetcode-cn.com/problems/next-permutation/&lt;/p&gt;&lt;/div&gt;&lt;/a&gt;&lt;/div&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>环形链表问题</title>
    <link href="http://jums.club/is-cycle/"/>
    <id>http://jums.club/is-cycle/</id>
    <published>2020-11-13T07:39:42.000Z</published>
    <updated>2020-11-13T11:34:56.569Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\leetcode\assets\css\APlayer.min.css"><script src="\leetcode\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="tag link"><a class="link-card" title="141. 环形链表" href="https://leetcode-cn.com/problems/linked-list-cycle/"><div class="left"><img src="https://jums.club/leetcode/images/safari.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/safari.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">141. 环形链表</p><p class="url">https://leetcode-cn.com/problems/linked-list-cycle/</p></div></a></div><a id="more"></a><blockquote><p>给定一个链表，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><p> 进阶：</p><p>你能用 O(1)（即，常量）内存解决此问题吗？</p><p>示例 1：</p> <img src="https://jums.club/leetcode/images/circularlinkedlist.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/circularlinkedlist.png" srcset="data:image/png;base64,666" style="zoom:67%;" /><p>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p><img src="https://jums.club/leetcode/images/circularlinkedlist_test2.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/circularlinkedlist_test2.png" srcset="data:image/png;base64,666" style="zoom:67%;" /><p>输入：head = [1,2], pos = 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p><img src="https://jums.club/leetcode/images/circularlinkedlist_test3.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/circularlinkedlist_test3.png" srcset="data:image/png;base64,666" style="zoom:67%;" /><p>输入：head = [1], pos = -1<br>输出：false<br>解释：链表中没有环。</p><p>提示：</p><p>链表中节点的数目范围是 $[0, 104]$<br>$-105 &lt;= Node.val &lt;= 105$<br>$pos$ 为$ -1$ 或者链表中的一个 有效索引 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle">https://leetcode-cn.com/problems/linked-list-cycle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="1-解题思路"><a href="#1-解题思路" class="headerlink" title="1 解题思路"></a>1 解题思路</h2><p>想象一下这种场景：在足球场上，甲和乙在进行跑步比赛，已知甲和乙的速度恒定不变，且甲的速度是乙的两倍，假设乙的速度是$v$，则甲的速度是$2v$。他们在同一时刻起跑，那么最后总有这么一个时刻，甲能追上乙，即甲乙相遇。</p><p>此问题和上面的场景有点像，那么我们只需要制造甲和乙，并且指定他们的速度就可以。可以使用快慢指针$slow$、$fast$，如果链表中存在环，那么这两个指针最终一定可以相遇，即$slow==fast$。如果他们最后相等了，那么说明有环，否则说明没有。代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-题目进阶"><a href="#2-题目进阶" class="headerlink" title="2 题目进阶"></a>2 题目进阶</h2><blockquote><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p><p>说明：不允许修改给定的链表。</p><p>进阶：</p><p>你是否可以使用 O(1) 空间解决此题？</p><p>示例 1：</p><img src="https://jums.club/leetcode/images/circularlinkedlist.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/circularlinkedlist.png" srcset="data:image/png;base64,666" style="zoom:67%;" /><p>输入：head = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p><img src="https://jums.club/leetcode/images/circularlinkedlist_test2.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/circularlinkedlist_test2.png" srcset="data:image/png;base64,666" style="zoom:67%;" /><p>输入：head = [1,2], pos = 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p><img src="https://jums.club/leetcode/images/circularlinkedlist_test3.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/circularlinkedlist_test3.png" srcset="data:image/png;base64,666" style="zoom:67%;" /><p>输入：head = [1], pos = -1<br>输出：返回 null<br>解释：链表中没有环。</p><p>提示：</p><p>链表中节点的数目范围在范围 $[0, 104]$内<br>$-105 &lt;= Node.val &lt;= 105$<br>$pos$ 的值为$ -1$ 或者链表中的一个有效索引</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii">https://leetcode-cn.com/problems/linked-list-cycle-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>此题目是在上一题的基础上的改进，即如果链表中存在环，那么求出环的入口节点并返回该入口节点。</p><p><img src="https://jums.club/leetcode/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201113160035.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201113160035.png" srcset="data:image/png;base64,666"></p><p>假设端点$A$是链表的起始点，端点$B$是链表中环的入口节点，端点$C$是快慢指针相遇的节点，由于快指针$fast$的移动速度是慢指针$slow$的两倍，所以可以知道快指针所走过的路径是慢指针所走过的路径的两倍。看图可以知道，慢指针所走过的路径是：$x+y$；快指针所走过的路径是：$x+y+y+z$，即$x+z+2y$。则有$2(x+y)=x+z+2y$，化简后的$x=z$。</p><p>根据以上推理过程，可以知道$x$和$z$的长度一样的，那么当快慢指针相遇之后，可以将快慢指针中的某个指针移动到链表头部，此时让快慢指针以相同的速度向前进，他们最终一定会在$B$点相遇，那么$B$点就是环的入口节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode s = head;</span><br><span class="line">        ListNode f = head;</span><br><span class="line">        <span class="keyword">while</span> (f != <span class="keyword">null</span> &amp;&amp; f.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s = s.next;</span><br><span class="line">            f = f.next.next;</span><br><span class="line">            <span class="keyword">if</span> (s == f) </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f = head;</span><br><span class="line">        <span class="keyword">while</span> (f != s &amp;&amp; s != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s = s.next;</span><br><span class="line">            f = f.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;141. 环形链表&quot; href=&quot;https://leetcode-cn.com/problems/linked-list-cycle/&quot;&gt;&lt;div class=&quot;left&quot;&gt;&lt;img src=&quot;https://jums.club/leetcode/images/safari.png&quot;/&gt;&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;p class=&quot;text&quot;&gt;141. 环形链表&lt;/p&gt;&lt;p class=&quot;url&quot;&gt;https://leetcode-cn.com/problems/linked-list-cycle/&lt;/p&gt;&lt;/div&gt;&lt;/a&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="LeetCode刷题" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    <category term="链表" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="middle" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/middle/"/>
    
    
    <category term="LeetCode刷题" scheme="http://jums.club/tags/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    <category term="middle" scheme="http://jums.club/tags/middle/"/>
    
    <category term="链表" scheme="http://jums.club/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>n人围成一圈报数</title>
    <link href="http://jums.club/n-people/"/>
    <id>http://jums.club/n-people/</id>
    <published>2020-11-13T07:19:14.000Z</published>
    <updated>2020-11-13T08:07:25.650Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\leetcode\assets\css\APlayer.min.css"><script src="\leetcode\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来的第几号的那位？</p></blockquote><a id="more"></a><h2 id="1-解题思路"><a href="#1-解题思路" class="headerlink" title="1 解题思路"></a>1 解题思路</h2><p>可以用一个数组，数组大小为$n$，需要执行$n-1$次遍历，每次遍历踢掉一个人，使用一个变量$p$来记录当前报的数，一个变量来保存当前还剩多少人，如果最后只剩下一个人，那么退出循环，否则继续。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nPeople</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count =  n;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] a = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!a[i]) p++;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="number">3</span>) &#123;</span><br><span class="line">                a[i] = <span class="keyword">true</span>;</span><br><span class="line">                count --;</span><br><span class="line">                p = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!a[i])</span><br><span class="line">            res = i +  <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-题目进阶"><a href="#2-题目进阶" class="headerlink" title="2 题目进阶"></a>2 题目进阶</h2><p>假如题目没有说从$1$报到$3$，而是从$1$报到$m$，则最后留下的那个人的编号是多少？</p><p><strong>在之前的基础上，进行改进即可，即对第$8$行代码进行，判断每次报数的最大值即可。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nPeople</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count =  n;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] a = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!a[i]) p++;</span><br><span class="line">            <span class="keyword">if</span> (p == m) &#123;</span><br><span class="line">                a[i] = <span class="keyword">true</span>;</span><br><span class="line">                count --;</span><br><span class="line">                p = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!a[i])</span><br><span class="line">            res = i +  <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来的第几号的那位？&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="http://jums.club/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="算法题" scheme="http://jums.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>328. 奇偶链表</title>
    <link href="http://jums.club/odd-even-list/"/>
    <id>http://jums.club/odd-even-list/</id>
    <published>2020-11-13T02:47:06.000Z</published>
    <updated>2020-11-13T02:57:50.063Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\leetcode\assets\css\APlayer.min.css"><script src="\leetcode\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="tag link"><a class="link-card" title="328. 奇偶链表" href="https://leetcode-cn.com/problems/odd-even-linked-list/"><div class="left"><img src="https://jums.club/leetcode/images/safari.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/safari.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">328. 奇偶链表</p><p class="url">https://leetcode-cn.com/problems/odd-even-linked-list/</p></div></a></div><a id="more"></a><blockquote><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p><p>示例 1:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL<br>示例 2:</p><p>输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL<br>输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL<br>说明:</p><p>应当保持奇数节点和偶数节点的相对顺序。<br>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/odd-even-linked-list">https://leetcode-cn.com/problems/odd-even-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="1-解题思路"><a href="#1-解题思路" class="headerlink" title="1 解题思路"></a>1 解题思路</h2><p>这里借助<a href="https://leetcode-cn.com/problems/odd-even-linked-list/solution/qi-ou-lian-biao-by-leetcode-solution/">力扣官网的题解</a>进行分析，首先由于奇数链表的头结点就是原始链表的第一个节点，所以定义一个奇数节点的头结点$oddHean=head$，而偶数链表的头结点则是奇数头结点的下一个节点，即$evenHead=head.next$。然后定义两个指针，一个指向奇数节点的指针$odd$，一个指向偶数节点的指针$even$，使用循环，他们的操作如下：</p><ul><li>奇数节点的下一个节点就是偶数节点的下一个节点，所以有$odd.next=even.next$，然后奇数节点向后移动，$odd=odd.next$。</li><li>偶数节点的下一个节点就是奇数节点的下一个节点，所有有$even.next=odd.next$，然后偶数节点向后移动，$even=even.next$</li></ul><p>最后将偶数链表的头结点连接到奇数节点的尾部，返回奇数链表的头结点即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode newHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        ListNode p2 = head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            newHead.next = p;</span><br><span class="line">            p = p.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">        <span class="keyword">while</span> (p2 != <span class="keyword">null</span> &amp;&amp; p2.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            newHead.next = p2;</span><br><span class="line">            p2 = p2.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法的时间复杂度为$O(n)$，空间复杂度是$O(1)$。</p><p><img src="https://jums.club/leetcode/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201113105702.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201113105702.png" srcset="data:image/png;base64,666"></p>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;328. 奇偶链表&quot; href=&quot;https://leetcode-cn.com/problems/odd-even-linked-list/&quot;&gt;&lt;div class=&quot;left&quot;&gt;&lt;img src=&quot;https://jums.club/leetcode/images/safari.png&quot;/&gt;&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;p class=&quot;text&quot;&gt;328. 奇偶链表&lt;/p&gt;&lt;p class=&quot;url&quot;&gt;https://leetcode-cn.com/problems/odd-even-linked-list/&lt;/p&gt;&lt;/div&gt;&lt;/a&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="LeetCode刷题" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    <category term="链表" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="middle" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/middle/"/>
    
    
    <category term="LeetCode刷题" scheme="http://jums.club/tags/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    <category term="middle" scheme="http://jums.club/tags/middle/"/>
    
    <category term="链表" scheme="http://jums.club/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>10. 正则表达式匹配</title>
    <link href="http://jums.club/is-match/"/>
    <id>http://jums.club/is-match/</id>
    <published>2020-11-12T12:34:25.000Z</published>
    <updated>2020-11-12T12:51:32.606Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\leetcode\assets\css\APlayer.min.css"><script src="\leetcode\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="tag link"><a class="link-card" title="10. 正则表达式匹配" href="https://leetcode-cn.com/problems/regular-expression-matching/"><div class="left"><img src="https://jums.club/leetcode/images/safari.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/safari.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">10. 正则表达式匹配</p><p class="url">https://leetcode-cn.com/problems/regular-expression-matching/</p></div></a></div><a id="more"></a><blockquote><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><p>‘.’ 匹配任意单个字符<br>‘*’ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p><p>示例 1：</p><p>输入：s = “aa” p = “a”<br>输出：false<br>解释：”a” 无法匹配 “aa” 整个字符串。<br>示例 2:</p><p>输入：s = “aa” p = “a*”<br>输出：true<br>解释：因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。<br>示例 3：</p><p>输入：s = “ab” p = “.<em>“<br>输出：true<br>解释：”.</em>“ 表示可匹配零个或多个（’*’）任意字符（’.’）。<br>示例 4：</p><p>输入：s = “aab” p = “c<em>a</em>b”<br>输出：true<br>解释：因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。<br>示例 5：</p><p>输入：s = “mississippi” p = “mis<em>is</em>p*.”<br>输出：false</p><p>提示：</p><p>$0 &lt;= s.length &lt;= 20$<br>$0 &lt;= p.length &lt;= 30$<br>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。<br>保证每次出现字符 * 时，前面都匹配到有效的字符       </p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/regular-expression-matching">https://leetcode-cn.com/problems/regular-expression-matching</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="1-解题思路"><a href="#1-解题思路" class="headerlink" title="1 解题思路"></a>1 解题思路</h2><p>本题可以使用动态规划来进行求解，定义$dp$数组，$dp[i][j]$表示字符串$s$的前$i$个字符和字符串$p$的前$j$的字符是否匹配。默认$dp[0][0]=true$，且$dp[m+1][n+1]$。</p><ul><li><p>情况1：<br>$s[i-1]==p[j-1]$或者$p[j-1]==’.’$，则表示能匹配，在匹配的情况下，则只要看第$i-1$和$j-1$的匹配情况即可，即$dp[i][j]=dp[i-1][j-1]$。</p></li><li><p>情况2：</p><p>$p[j-1]=’*’$，此时表示字符串$p$之前的字符可以匹配0个、1个或者多个，分成以下几种情况</p><ul><li><p>子情况1：</p><p>$s[i-1]==p[j-2]$或者$p[j-2]==’.’$，表示前一个字符可以匹配，则表示$*$号之前的字符出现了一个，则$dp[i][j]=dp[i][j-1]$。</p></li><li><p>子情况2：</p><p>$s[i-1]!=p[j-2]$时，此时$<em>$可以匹配0个、1个或者多个$</em>$号之前的字符，则</p><p>$dp[i][j]=dp[i-1][j]ordp[i][j-1]ordp[i][j-2]$。</p><p>其中$dp[i][j-2]$表示匹配0个字符，$dp[i][j-1]$表示匹配1个字符，$dp[i-1][j]$表示匹配多个字符。</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        String s1 = <span class="string">&quot; &quot;</span> + s; <span class="comment">//避免比较空字符串</span></span><br><span class="line">        String p2 = <span class="string">&quot; &quot;</span> + p;</span><br><span class="line">        <span class="keyword">int</span> m = s1.length();</span><br><span class="line">        <span class="keyword">int</span> n = p2.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s1.charAt(i - <span class="number">1</span>) == p2.charAt(j - <span class="number">1</span>) || p2.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s1.charAt(i - <span class="number">1</span>) != p2.charAt(j - <span class="number">2</span>) &amp;&amp; p2.charAt(j - <span class="number">2</span>) != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                        dp[i][j] = dp[i][j - <span class="number">2</span>]; <span class="comment">//出现0次</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">//s.charAt(i - 1) != p.charAt(j - 2)</span></span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j] <span class="comment">//匹配多个字符】</span></span><br><span class="line">                        || dp[i][j - <span class="number">2</span>] <span class="comment">//匹配0个字符</span></span><br><span class="line">                        || dp[i][j - <span class="number">1</span>]; <span class="comment">//匹配1个字符</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;10. 正则表达式匹配&quot; href=&quot;https://leetcode-cn.com/problems/regular-expression-matching/&quot;&gt;&lt;div class=&quot;left&quot;&gt;&lt;img src=&quot;https://jums.club/leetcode/images/safari.png&quot;/&gt;&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;p class=&quot;text&quot;&gt;10. 正则表达式匹配&lt;/p&gt;&lt;p class=&quot;url&quot;&gt;https://leetcode-cn.com/problems/regular-expression-matching/&lt;/p&gt;&lt;/div&gt;&lt;/a&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="LeetCode刷题" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    <category term="动态规划" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="hard" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/hard/"/>
    
    
    <category term="LeetCode刷题" scheme="http://jums.club/tags/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    <category term="hard" scheme="http://jums.club/tags/hard/"/>
    
    <category term="动态规划" scheme="http://jums.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>15. 三数之和</title>
    <link href="http://jums.club/three-sum/"/>
    <id>http://jums.club/three-sum/</id>
    <published>2020-11-12T10:49:08.000Z</published>
    <updated>2020-11-12T12:38:27.152Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\leetcode\assets\css\APlayer.min.css"><script src="\leetcode\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="tag link"><a class="link-card" title="15. 三数之和" href="https://leetcode-cn.com/problems/3sum/"><div class="left"><img src="https://jums.club/leetcode/images/safari.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/safari.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">15. 三数之和</p><p class="url">https://leetcode-cn.com/problems/3sum/</p></div></a></div><a id="more"></a><blockquote><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>示例：</p><p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p><p>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/3sum">https://leetcode-cn.com/problems/3sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="1-解题思路"><a href="#1-解题思路" class="headerlink" title="1 解题思路"></a>1 解题思路</h2><p>排序+双指针</p><p>定义三个指针$a,b,c$，然后固定其中一个，移动其中两个，假设固定$a$，然后令$b=a+1$，$c=size-1$，移动指针$b$和$c$。有以下三种情况：</p><ul><li>大于0：即$nums[a]+nums[b]+nums[c]&gt;0$，此时应该指针$d$左移</li><li>小于0：即$nums[a]+nums[b]+nums[c]&lt;0$，此时应该指针$c$右移</li><li>等于0：添加到结果集</li></ul><p><strong>注意：题目中说结果集中不能含有重复结果，所以需要判断相邻元素的值是否相等，相等则跳过。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> size = nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size - <span class="number">2</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">//去重</span></span><br><span class="line">            <span class="keyword">int</span> l = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> r = size - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[l] + nums[r] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    r --;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[l] + nums[r] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    l ++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    List&lt;Integer&gt; tem = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    tem.add(nums[i]);</span><br><span class="line">                    tem.add(nums[l]);</span><br><span class="line">                    tem.add(nums[r]);</span><br><span class="line">                    ans.add(tem);</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l + <span class="number">1</span>]) l ++; <span class="comment">//去重</span></span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r - <span class="number">1</span>]) r --; <span class="comment">//去重</span></span><br><span class="line">                    l ++;</span><br><span class="line">                    r --;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;15. 三数之和&quot; href=&quot;https://leetcode-cn.com/problems/3sum/&quot;&gt;&lt;div class=&quot;left&quot;&gt;&lt;img src=&quot;https://jums.club/leetcode/images/safari.png&quot;/&gt;&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;p class=&quot;text&quot;&gt;15. 三数之和&lt;/p&gt;&lt;p class=&quot;url&quot;&gt;https://leetcode-cn.com/problems/3sum/&lt;/p&gt;&lt;/div&gt;&lt;/a&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="LeetCode刷题" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    <category term="双指针" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="middle" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E5%8F%8C%E6%8C%87%E9%92%88/middle/"/>
    
    
    <category term="LeetCode刷题" scheme="http://jums.club/tags/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    <category term="middle" scheme="http://jums.club/tags/middle/"/>
    
    <category term="双指针" scheme="http://jums.club/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>18.四数之和</title>
    <link href="http://jums.club/four-sum/"/>
    <id>http://jums.club/four-sum/</id>
    <published>2020-11-12T10:31:44.000Z</published>
    <updated>2020-11-12T10:59:37.552Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\leetcode\assets\css\APlayer.min.css"><script src="\leetcode\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="tag link"><a class="link-card" title="18. 四数之和" href="https://leetcode-cn.com/problems/4sum/"><div class="left"><img src="https://jums.club/leetcode/images/safari.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/safari.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">18. 四数之和</p><p class="url">https://leetcode-cn.com/problems/4sum/</p></div></a></div><a id="more"></a><blockquote><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><p>注意：</p><p>答案中不可以包含重复的四元组。</p><p>示例：</p><p>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。</p><p>满足要求的四元组集合为：<br>[<br>  [-1,  0, 0, 1],<br>  [-2, -1, 1, 2],<br>  [-2,  0, 0, 2]<br>]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/4sum">https://leetcode-cn.com/problems/4sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="1-解题思"><a href="#1-解题思" class="headerlink" title="1 解题思"></a>1 解题思</h2><p>思路：排序+双指针</p><p>在<a href="https://jums.club/leetcode/three-sum/">15. 三数之和</a>的基础上，多定义一个下届即可，定义四个指针，$a,b,c,d$，先固定$a$和$b$，$b=a+1$，然后再定义双指针$c$和$d$，令$c=b+1$，$d=size-1$，然后判断这四个指针的数值的和是否与$target$的结果：</p><ul><li>当$nums[a]+nums[b]+nums[c]+nums[d]==target$，符合要求，添加到结果集中</li><li>当$nums[a]+nums[b]+nums[c]+nums[d]&gt;target$，太大，应该让指针$d$左移动</li><li>当$nums[a]+nums[b]+nums[c]+nums[d]&lt;target$，太小，应该让指针$c$右移动</li></ul><p><strong>注意：在计算时，要防止各个指针所指向的值是否想等，如果某一个指针的前一个值和后一个相等，则不参与计算，因为结果集中不能出现重复结果。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">        <span class="keyword">int</span> size = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">4</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;= size- <span class="number">4</span>; a ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a &gt; <span class="number">0</span> &amp;&amp; nums[a] == nums[a - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">//去重</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = a + <span class="number">1</span>; b &lt;= size - <span class="number">3</span>; b ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (b &gt; a + <span class="number">1</span> &amp;&amp; nums[b] == nums[b - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">//去重</span></span><br><span class="line">                <span class="keyword">int</span> c = b + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> d = size - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (c &lt; d) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[a] + nums[b] + nums[c] + nums[d] &lt; target) &#123;</span><br><span class="line">                        c ++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[a] + nums[b] + nums[c] + nums[d] &gt; target) &#123;</span><br><span class="line">                        d --;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        List&lt;Integer&gt; tem = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                        tem.add(nums[a]);</span><br><span class="line">                        tem.add(nums[b]);</span><br><span class="line">                        tem.add(nums[c]);</span><br><span class="line">                        tem.add(nums[d]);</span><br><span class="line">                        ans.add(tem);</span><br><span class="line">                        <span class="keyword">while</span> (c &lt; d &amp;&amp; nums[c + <span class="number">1</span>] == nums[c]) c++; <span class="comment">//去重</span></span><br><span class="line">                        <span class="keyword">while</span> (c &lt; d &amp;&amp; nums[d - <span class="number">1</span>] == nums[d]) d--; <span class="comment">//去重</span></span><br><span class="line">                        c++;</span><br><span class="line">                        d--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;18. 四数之和&quot; href=&quot;https://leetcode-cn.com/problems/4sum/&quot;&gt;&lt;div class=&quot;left&quot;&gt;&lt;img src=&quot;https://jums.club/leetcode/images/safari.png&quot;/&gt;&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;p class=&quot;text&quot;&gt;18. 四数之和&lt;/p&gt;&lt;p class=&quot;url&quot;&gt;https://leetcode-cn.com/problems/4sum/&lt;/p&gt;&lt;/div&gt;&lt;/a&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="LeetCode刷题" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    <category term="middle" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/middle/"/>
    
    <category term="双指针" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/middle/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    
    <category term="LeetCode刷题" scheme="http://jums.club/tags/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    <category term="middle" scheme="http://jums.club/tags/middle/"/>
    
    <category term="双指针" scheme="http://jums.club/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>514. 自由之路</title>
    <link href="http://jums.club/find-rotate-steps/"/>
    <id>http://jums.club/find-rotate-steps/</id>
    <published>2020-11-12T07:23:42.000Z</published>
    <updated>2020-11-12T12:38:11.090Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\leetcode\assets\css\APlayer.min.css"><script src="\leetcode\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="tag link"><a class="link-card" title="514. 自由之路， https://leetcode-cn.com/problems/freedom-trail/" href="https://jums.club/leetcode/images/safari.png"><div class="left"><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">514. 自由之路， https://leetcode-cn.com/problems/freedom-trail/</p><p class="url">https://jums.club/leetcode/images/safari.png</p></div></a></div><a id="more"></a><blockquote><p>电子游戏“辐射4”中，任务“通向自由”要求玩家到达名为“Freedom Trail Ring”的金属表盘，并使用表盘拼写特定关键词才能开门。</p><p>给定一个字符串 ring，表示刻在外环上的编码；给定另一个字符串 key，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的最少步数。</p><p>最初，ring 的第一个字符与12:00方向对齐。您需要顺时针或逆时针旋转 ring 以使 key 的一个字符在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完 key 中的所有字符。</p><p>旋转 ring 拼出 key 字符 key[i] 的阶段中：</p><p>您可以将 ring 顺时针或逆时针旋转一个位置，计为1步。旋转的最终目的是将字符串 ring 的一个字符与 12:00 方向对齐，并且这个字符必须等于字符 key[i] 。<br>如果字符 key[i] 已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作 1 步。按完之后，您可以开始拼写 key 的下一个字符（下一阶段）, 直至完成所有拼写。<br>示例：</p><p> <img src="https://jums.club/leetcode/images/ring.jpg" class="lazyload" data-srcset="https://jums.club/leetcode/images/ring.jpg" srcset="data:image/png;base64,666"></p><p>输入: ring = “godding”, key = “gd”<br>输出: 4<br>解释:<br> 对于 key 的第一个字符 ‘g’，已经在正确的位置, 我们只需要1步来拼写这个字符。<br> 对于 key 的第二个字符 ‘d’，我们需要逆时针旋转 ring “godding” 2步使它变成 “ddinggo”。<br> 当然, 我们还需要1步进行拼写。<br> 因此最终的输出是 4。<br>提示：</p><p>ring 和 key 的字符串长度取值范围均为 1 至 100；<br>两个字符串中都只有小写字符，并且均可能存在重复字符；<br>字符串 key 一定可以由字符串 ring 旋转拼出。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/freedom-trail">https://leetcode-cn.com/problems/freedom-trail</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="1-解题思路"><a href="#1-解题思路" class="headerlink" title="1 解题思路"></a>1 <a href="https://leetcode-cn.com/problems/freedom-trail/solution/zi-you-zhi-lu-by-leetcode-solution/">解题思路</a></h2><p>使用动态规划进行求解，$dp[i][j]$表示字符串$key$中的第$i$个字符和$ring$中的第$j$个字符对应时，所需要的最小转换步数。由于题目中说：</p><ul><li>可以顺时针和逆时针转动</li><li>可以有重复字符</li></ul><p>所以增加了题目的难度，不能使用贪心算法，得用动态规划进行求解。</p><p>状态转移方程：</p><p>$dp[i][j]=max(dp[i][j],dp[i][k]+1+min(abs(j-k),abs(n-(j-k))))$</p><p>其中$n$表示$ring$的长度，$1+min(abs(j-k),abs(n-(j-k)))$表示$key$中的第$k$个字符对应在$ring$中的索引转换到$ring$中第$j$个字符所需要的最短步数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRotateSteps</span><span class="params">(String ring, String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = ring.length(), m = key.length();</span><br><span class="line">        List&lt;Integer&gt;[] pos = <span class="keyword">new</span> List[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            pos[i] = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            pos[ring.charAt(i) - <span class="string">&#x27;a&#x27;</span>].add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            Arrays.fill(dp[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : pos[key.charAt(<span class="number">0</span>) - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = Math.min(i, n - i) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j : pos[key.charAt(i) - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k : pos[key.charAt(i - <span class="number">1</span>) - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i - <span class="number">1</span>][k] + Math.min(Math.abs(j - k), n - Math.abs(j - k)) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(dp[m - <span class="number">1</span>]).min().getAsInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度是$O(mn^2)$</p><p>空间复杂度是$O(mn)$</p>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;514. 自由之路， https://leetcode-cn.com/problems/freedom-trail/&quot; href=&quot;https://jums.club/leetcode/images/safari.png&quot;&gt;&lt;div class=&quot;left&quot;&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png&quot;/&gt;&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;p class=&quot;text&quot;&gt;514. 自由之路， https://leetcode-cn.com/problems/freedom-trail/&lt;/p&gt;&lt;p class=&quot;url&quot;&gt;https://jums.club/leetcode/images/safari.png&lt;/p&gt;&lt;/div&gt;&lt;/a&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="LeetCode刷题" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    <category term="动态规划" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="hard" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/hard/"/>
    
    
    <category term="LeetCode刷题" scheme="http://jums.club/tags/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    <category term="hard" scheme="http://jums.club/tags/hard/"/>
    
    <category term="动态规划" scheme="http://jums.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>打家劫舍</title>
    <link href="http://jums.club/house-robber/"/>
    <id>http://jums.club/house-robber/</id>
    <published>2020-11-12T02:33:54.000Z</published>
    <updated>2020-11-12T12:38:37.178Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\leetcode\assets\css\APlayer.min.css"><script src="\leetcode\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="tag link"><a class="link-card" title="198. 打家劫舍" href="https://leetcode-cn.com/problems/house-robber/"><div class="left"><img src="https://jums.club/leetcode/images/safari.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/safari.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">198. 打家劫舍</p><p class="url">https://leetcode-cn.com/problems/house-robber/</p></div></a></div><a id="more"></a><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>示例 1：</p><p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。<br>示例 2：</p><p>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p><p>提示：</p><p>0 &lt;= nums.length &lt;= 100<br>0 &lt;= nums[i] &lt;= 400</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/house-robber">https://leetcode-cn.com/problems/house-robber</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="1-解题思路"><a href="#1-解题思路" class="headerlink" title="1 解题思路"></a>1 解题思路</h2><p>劫匪遇到一间屋子，有两种选择，一是打劫，二是不打劫。如果打劫，则需要第$i-1$个屋子没有被打劫，也就是说，第$i-1$个屋子不能被算到总的金额中。如果不打劫，则打劫到当前屋子的最高金额就是打劫到第$i-1$个屋子所能获得的最高金额。</p><p>定义一个$dp$数组，$dp[i]$表示到第$i$个屋子为止，劫匪所能获得的最大金额，则：</p><p>$dp[i]=max(dp[i-1],dp[i-2]+nums[i])$</p><ul><li>$dp[i-1]$，表示不打劫第$i$个屋子所能获得的最大金额</li><li>$dp[i-2]+nums[i]$，表示打劫第$i$个屋子所能获得的最大金额</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            dp[i] = Math.max(</span><br><span class="line">                            dp[i - <span class="number">1</span>], <span class="comment">//不打劫第i个房子</span></span><br><span class="line">                            dp[i - <span class="number">2</span>] + nums[i] <span class="comment">//打劫第i个房子</span></span><br><span class="line">                            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;198. 打家劫舍&quot; href=&quot;https://leetcode-cn.com/problems/house-robber/&quot;&gt;&lt;div class=&quot;left&quot;&gt;&lt;img src=&quot;https://jums.club/leetcode/images/safari.png&quot;/&gt;&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;p class=&quot;text&quot;&gt;198. 打家劫舍&lt;/p&gt;&lt;p class=&quot;url&quot;&gt;https://leetcode-cn.com/problems/house-robber/&lt;/p&gt;&lt;/div&gt;&lt;/a&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="LeetCode刷题" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    <category term="动态规划" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="simple" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/simple/"/>
    
    
    <category term="LeetCode刷题" scheme="http://jums.club/tags/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    <category term="动态规划" scheme="http://jums.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="simple" scheme="http://jums.club/tags/simple/"/>
    
  </entry>
  
  <entry>
    <title>922. 按奇偶排序数组 II</title>
    <link href="http://jums.club/sort-array-by-parity-ii/"/>
    <id>http://jums.club/sort-array-by-parity-ii/</id>
    <published>2020-11-12T01:52:16.000Z</published>
    <updated>2020-11-12T10:35:56.538Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\leetcode\assets\css\APlayer.min.css"><script src="\leetcode\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="tag link"><a class="link-card" title="922. 按奇偶排序数组 II，https://leetcode-cn.com/problems/sort-array-by-parity-ii/" href="https://jums.club/leetcode/images/safari.png"><div class="left"><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">922. 按奇偶排序数组 II，https://leetcode-cn.com/problems/sort-array-by-parity-ii/</p><p class="url">https://jums.club/leetcode/images/safari.png</p></div></a></div><a id="more"></a><blockquote><p>给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。</p><p>对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。</p><p>你可以返回任何满足上述条件的数组作为答案。</p><p>示例：</p><p>输入：[4,2,5,7]<br>输出：[4,5,2,7]<br>解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。</p><p>提示：</p><p>2 &lt;= A.length &lt;= 20000<br>A.length % 2 == 0<br>0 &lt;= A[i] &lt;= 1000</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sort-array-by-parity-ii">https://leetcode-cn.com/problems/sort-array-by-parity-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="1-解题思路"><a href="#1-解题思路" class="headerlink" title="1 解题思路"></a>1 解题思路</h2><p>使用两次遍历，一次确定偶数的位置，一次确定奇数的位置。</p><p>时间复杂度是$O(n)$，空间复杂度是$O(1)$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArrayByParityII(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> odd = <span class="number">1</span>, even = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : A) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                res[even] = a;</span><br><span class="line">                even += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : A) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                res[odd] = a;</span><br><span class="line">                odd += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;922. 按奇偶排序数组 II，https://leetcode-cn.com/problems/sort-array-by-parity-ii/&quot; href=&quot;https://jums.club/leetcode/images/safari.png&quot;&gt;&lt;div class=&quot;left&quot;&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png&quot;/&gt;&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;p class=&quot;text&quot;&gt;922. 按奇偶排序数组 II，https://leetcode-cn.com/problems/sort-array-by-parity-ii/&lt;/p&gt;&lt;p class=&quot;url&quot;&gt;https://jums.club/leetcode/images/safari.png&lt;/p&gt;&lt;/div&gt;&lt;/a&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="LeetCode刷题" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    <category term="simple" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/simple/"/>
    
    
    <category term="LeetCode刷题" scheme="http://jums.club/tags/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    <category term="simple" scheme="http://jums.club/tags/simple/"/>
    
  </entry>
  
  <entry>
    <title>下一个全排列</title>
    <link href="http://jums.club/next-permutation/"/>
    <id>http://jums.club/next-permutation/</id>
    <published>2020-11-10T12:19:06.000Z</published>
    <updated>2020-11-12T12:38:00.794Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\leetcode\assets\css\APlayer.min.css"><script src="\leetcode\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><a id="more"></a><div class="tag link"><a class="link-card" title="31. 下一个排列" href="https://leetcode-cn.com/problems/next-permutation/"><div class="left"><img src="https://jums.club/leetcode/images/safari.png" class="lazyload" data-srcset="https://jums.club/leetcode/images/safari.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">31. 下一个排列</p><p class="url">https://leetcode-cn.com/problems/next-permutation/</p></div></a></div><blockquote><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须原地修改，只允许使用额外常数空间。</p><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/next-permutation">https://leetcode-cn.com/problems/next-permutation</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="解释思路"><a href="#解释思路" class="headerlink" title="解释思路"></a>解释思路</h2><p>从后往前遍历数组，找到第一个小于当前索引位置的数，假设当前索引是$i$，则找到$i-1$，有以下三种情况：</p><p>1.$i==nums.length$，说明数组是一个升序数组，直接交换$nums[i]$和$nums[i-1]$的位置即可，如$123$-&gt;$132$</p><p>2.$0&lt;i&lt;nums.length$，说明这样的数在数组中间，直接从第$[i…nums.length]$的数中找到一个大于且仅大于$nums[i-1]$的数，即这个数是$[i…nums.length]$中大于$nums[i-1]$中最小的，假设该索引是$min$，然后交换$nums[i-1]$和$nums[min]$的值，并将$[i…nums.length]$中的所有数进行升序排序，便是最终答案</p><p>3.$i==0$，说明数组是一个倒序的数组，直接将数组$reverse$即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//12345 -&gt; 12354</span></span><br><span class="line">            <span class="keyword">if</span> (i == nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">                nums[i] = nums[i - <span class="number">1</span>] ^ nums[i];</span><br><span class="line">                nums[i - <span class="number">1</span>] = nums[i - <span class="number">1</span>] ^ nums[i];</span><br><span class="line">                nums[i] = nums[i - <span class="number">1</span>] ^ nums[i];</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> min = i; <span class="comment">//从[i,nums.length-1]的闭区间中找到一个大于nums[i - 1]的最小的值，并与nums[i - 1]交换</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = nums.length - <span class="number">1</span>; j &gt;= i; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[i - <span class="number">1</span>] &amp;&amp; nums[j] &lt; nums[min])</span><br><span class="line">                    min = j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nums[i- <span class="number">1</span>] = nums[i - <span class="number">1</span>] ^ nums[min];</span><br><span class="line">            nums[min] = nums[i - <span class="number">1</span>] ^ nums[min];</span><br><span class="line">            nums[i- <span class="number">1</span>] = nums[i - <span class="number">1</span>] ^ nums[min];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将第i个位置以后的数字进行升序排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; nums.length - <span class="number">1</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[k] &gt; nums[k + <span class="number">1</span>]) &#123;</span><br><span class="line">                        nums[k] = nums[k] ^ nums[k + <span class="number">1</span>];</span><br><span class="line">                        nums[k + <span class="number">1</span>] = nums[k] ^ nums[k + <span class="number">1</span>];</span><br><span class="line">                        nums[k] = nums[k] ^ nums[k + <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//倒序数组</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            nums[l] = nums[l] ^ nums[r];</span><br><span class="line">            nums[r] = nums[l] ^ nums[r];</span><br><span class="line">            nums[l] = nums[l] ^ nums[r];</span><br><span class="line">            l ++;</span><br><span class="line">            r --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\leetcode\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\leetcode\assets\js\A</summary>
      
    
    
    
    <category term="LeetCode刷题" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    <category term="排序算法" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="middle" scheme="http://jums.club/categories/LeetCode%E5%88%B7%E9%A2%98/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/middle/"/>
    
    
    <category term="LeetCode刷题" scheme="http://jums.club/tags/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    <category term="middle" scheme="http://jums.club/tags/middle/"/>
    
    <category term="排序算法" scheme="http://jums.club/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二分搜索</title>
    <link href="http://jums.club/binary-search/"/>
    <id>http://jums.club/binary-search/</id>
    <published>2020-11-10T07:33:01.000Z</published>
    <updated>2020-11-10T10:52:51.657Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\leetcode\assets\css\APlayer.min.css"><script src="\leetcode\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1 时间复杂度"></a>1 时间复杂度</h2><p>二分查找的思想很简单，前提是数组是有序的，查找的时间复杂度是$O(logn)$。利用三个指针，分别指向数组的头部、中间和尾部，如果待查找的元素$target$在数组的前半部分，则跳转到前半部分查找，如果在后半部分，则跳转到后半部分进行查找，当头部的值大于尾部指针的值时，则表示查不到。</p><a id="more"></a><h2 id="2-关键代码"><a href="#2-关键代码" class="headerlink" title="2 关键代码"></a>2 关键代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> []nums, <span class="keyword">int</span>  target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)<span class="comment">//到后半部分查找</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid - <span class="number">1</span>;<span class="comment">//到前半部分查找  如果第3行中用的是while(l&lt;r)，则此行应该写成开区间，即r=mid;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-时间复杂度&quot;&gt;&lt;a href=&quot;#1-时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;1 时间复杂度&quot;&gt;&lt;/a&gt;1 时间复杂度&lt;/h2&gt;&lt;p&gt;二分查找的思想很简单，前提是数组是有序的，查找的时间复杂度是$O(logn)$。利用三个指针，分别指向数组的头部、中间和尾部，如果待查找的元素$target$在数组的前半部分，则跳转到前半部分查找，如果在后半部分，则跳转到后半部分进行查找，当头部的值大于尾部指针的值时，则表示查不到。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://jums.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="搜索算法" scheme="http://jums.club/categories/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://jums.club/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="搜索算法" scheme="http://jums.club/tags/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
